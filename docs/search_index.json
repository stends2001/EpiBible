[["index.html", "Epibible Epibible", " Epibible Sten de Schrijver 2025-08-21 Epibible "],["preface.html", "Preface", " Preface Hi, and welcome! I truly appreciate you taking the time to look over this work of mine. This digital book is designed to serve as a reference covering essential concepts that everyone working in epidemiology should know. We will explore some (minimal) theoretical epidemiology and examine various epidemiological concepts through real-world disease scenarios. After introducing how R works and how it can be applied across many areas of public health, we will discuss how to access and manage epidemiological data. Finally, we’ll bring everything together so that, regardless of your background, you’ll gain a solid foundational experience in epidemiology using R, enabling you to confidently dive deeper into this fascinating field. Public health is a prime example of a multidisciplinary arena where diverse scientific fields converge. The One Health approach, in particular, not only connects different disciplines but also encourages multiple perspectives on the same issue. For example, a medical doctor may view a mosquito as a vector transmitting disease, while an ecologist might see it as an invasive species indicating changing habitat suitability, perhaps due to global warming. Although One Health experts recognize the importance of interdisciplinary collaboration and education, this integration often falls short when it comes to computers and data. This is precisely the gap this material aims to bridge. While this reader covers fundamental topics in epidemiology and R, it will gradually expand to include more advanced and diverse content of interest to a wide audience. For readers already familiar with R and data analysis, I will occasionally provide suggestions for further reading, highlight useful R packages, and touch upon emerging fields where epidemiology intersects with disciplines like machine learning. As this is a first draft intended as background material for a future course, I warmly welcome your feedback! Please feel free to share your thoughts by emailing me. "],["about-the-author.html", "About the Author", " About the Author As a graduate from a bachelor’s degree in Nanobiology (joint degree of the Techinical University in Delft and ERasmus Medical School, the Netherlands) and the MSc. Erasmus Mundus Joint Degree in Infectious Diseases and One Health, I have a solid background in molecular biology, infection biology, public health, epidemiology and data analytics. The fields specifically, I am now integrating on a daily basis during my PhD (Robert Koch Institut, Berlin) in artificial intelligence in public health. On a daily basis I look at the prevalence of vaccine-preventable diseases, and try to model dynamics and occurances of these diseases. During my studies, I have seen that people understand more and more the necessity of learning different skills from different fields, to become a more “well - rounded” scientist. While advocating for this, I have also experienced the hesitancy of both students and specialists to take up new skills of the digital and the mathematical area. Especially in the information age that we live in, I find it inexcplicable that students graduating from degrees in public health have practically no experience with working with data. "],["introduction-to-epidemiology.html", "Chapter 1 Introduction to Epidemiology", " Chapter 1 Introduction to Epidemiology I still need to look into this. "],["working-with-this-book.html", "Chapter 2 Working with this book 2.1 What is bookdown? 2.2 What is Markdown 2.3 Code snippets 2.4 Other formats in this book", " Chapter 2 Working with this book Before diving into the coding content, this chapter explains how this book is organized and how you can make th;e most of the examples and code snippets provied throughout this book. 2.1 What is bookdown? This book is written using bookdown, a pakage in R that helps create digital books and long-form documents using R Markdown. Bookdowns allow us to do multiple things, in one clean and organized document: combine text and executable R code in one place automatically generates formatted output like HTML, PDF or e-books Cross-reference chapters, figures tables and equations provide code snippets that any reader can copy paste into executable code chunks for easy practice. 2.2 What is Markdown The continent you see here is written in Markdown, a simple plain-text formatting syntax that’s easy to write and read. Markdown allows you to add: Headings and subheadings Formatted text (bold, italic) 2.3 Code snippets Throughout this book you will find code chunks like the one on the next few lines. In grey and italic you will see comments, denoted by starting with a hashtag (‘#’). Any normal looking text is executable code. Upon generation of this bookdown, all code chunks that are written are executed. Below each chunk, you find another grey background box, which holds the output of that chunk. # This is a comment print(&quot;this is executable code!&quot;) ## [1] &quot;this is executable code!&quot; Because these chunks are literally the code that I have written myself, you can simply copy paste this into your system, and thereby run the same code. 2.4 Other formats in this book There’s a few common text-formats. I’ll be using these: bold: terminology italic: variables in functions inline code: functions "],["getting-started-with-r.html", "Chapter 3 Getting Started with R 3.1 Installing R and Rstudio 3.2 Starting to code", " Chapter 3 Getting Started with R 3.1 Installing R and Rstudio R is not a computer program like Microsoft Word. Instead, it is a computer language, just like Python, Matlab, Java and many others. You can tell your computer to execute commands, by writing the commands in such a computer language. RStudio is an interface, an application, that functions as a tool to help you write, understand and organize your R code. In order to get R up and running on your system we therefore need to install both R and Rstudio. Follow the steps on this website specifically for your system (Linux, Mac, Windows). After installation, you can open the application RStudio and in it run Rcode. You’ll notice 4 sections in RStudio: script editor (top left); this is where we will do most work. We will write and edit code in this place console (bottom left); this is where we execute code. while you can run R commands here directly, we will execute code here written in the script editor. environment pane (top right); shows all the current variables, datasets and anything else in the working memory file pane (bottom right); allows you to browse overfiles The R language is incredibly large and diverse. Any user of R can extend the language with new functions and new tools, which come together in the shape of a package. There are about 20 thousand (!) R packages available, each of which has their own speciality. When some clever person creates a new epidemiological model and wants it to become available for the community, they can upload it on R and make it available for us. While the volume of packages make it sound like you can easily lose track of everything that’s out there, there’s only a handful of packages that really everyone tends to use. For example, the Tidyverse is a collection of packages that many people workign with R have experience with. We will also be using it a lot in this course, specifically the packages ggplot2 (for visualization) dplyr (for data manipulation), readr (for reading datafiles) and tidyr (for reshaping dataframes). We will go through installing and loading packages, and writing functions later in this course. For now we can get started on some very simple things in R, to get you familiar with doing some coding! 3.2 Starting to code The print() function is a very basic and useful one, which allows you to often check some things quickly. On the first line in the script editor, go and write the following line: print(&#39;hello world!&#39;) ## [1] &quot;hello world!&quot; with your cursor on the right side of that line, press the “run”-button. You will see the output in the console where it now shows in yellow what has been executed, and in white the output is shown. R is great for doing some easy mathematics. Let’s do some calculations and print the output: x = 10 y = 280 z = 0.4 product = x*y*z print(product) ## [1] 1120 Here we have multiple lines of code, that we need to execute in that order for it to work. We can’t first run the print, and then do the calculations. We can either do that line by line, so press the run button each time. Alternatively, you can select all these lines, and then press the run button. Another option is to use the shortcut (Windows?) CTRL + Enter. This is the equivalent of the Run button. So select all the lines, and press CTRL + Enter We will discuss more R syntax, and more thigns to code, at a later point. For now let’s leave it at this and talk a bit about how we organize our code. ## R Projects and Organization We can save our code in an R script, which is the most basic R file. To do that, we go CTR + S and can navigate to the location to save our file. Besides this R file (extension: .R) we have a couple of other options, including an R Markdown. I am a huge fan of these. If you’re familiar with Python; R Markdown - files are the R equivalent of a jupyter notebook file. They allow you to write code in the same file as nicely organized text. You can put in graphs that look really nice, add citations and a bibliography, add chapters, and so much more. This whole textbook is actually running in a handful of R Markdown files. Eventually, I want to write a small project with you in an R Markdown as well, though for now we can get started with R scripts. To organize our R code properly, we shouldn’t work with individual R scripts. It is much better to have a specific environment for your R code, in which you store your analysis (code), your data and your results and figures. Something I struggle a lot with myself is with directories. A directory is a certain folder’s location, a way of pinpointing where R is working (the workign directory). This is important to know, because when we tell R where to find a certain dataset on our computer, the computer needs to know the starting point of our trip. To fix all these issues, we have something called an R project. This is exactly an environment to bundle different R files in a seperate folder, where the working directory is atuomatically set to the root of the project; the location of the project file. We create an R project through the following steps: File &gt; New Project A window will pop up asking to Save the current workspace: - Don’t save New Directory &gt; New Project In Directory name: write “epiproject_00” In Create project as a subdirectory of: - press browse, and navigate to a place on hyour computer you would like to store your R codes. I suggest this NOT TO BE your Downloads or Desktop folder. Create Project Now that we’re in a project, open a new R script. Save it in the project under the name “00_syntax” and let’s set started in the next chapter. "],["r-fundamentals.html", "Chapter 4 R fundamentals 4.1 Basic Datatypes in R 4.2 Special datatypes 4.3 Converting between datatypes 4.4 Data structures in R 4.5 Conditions and Comparisons 4.6 Conditional execution with 4.7 Repeating lines of code 4.8 Functions", " Chapter 4 R fundamentals 4.1 Basic Datatypes in R When coding, we work with variables. Say we start our code with x=1, then x is a variable. We can do some calculations with x, and we can change x, depending on the type of data that the variable is. In R, variables can represent the following datatypes: Type Description Example Numeric Real number 3.14, -6.7 Integer Whole number 1, 4, 16 Character Text or string a, hello! Logical Boolean TRUE, FALSE The specification of a datatype is very important. While some datatypes may allow certain functionality, others may not. We can sum two numeric variables, which we can also do for two integers. When we try to add two characters to each other though, R will throw an error. Have a look yourself. summing two numeric datatypes x = 1.1 y = 2.9 print(x+y) ## [1] 4 summing two characters text1 = &#39;hello&#39; text2 = &#39;there!&#39; # print(text1+text2) -&gt; this will throw an error! While this doesn’t work, there are ways of combining, or rather concatenating two strings, namely using paste() and paste0(): paste(text1, text2) ## [1] &quot;hello there!&quot; paste0(text1, text2) ## [1] &quot;hellothere!&quot; 4.2 Special datatypes Besides the basic types of variables mentioned below, R also supports some special datatypes: | Type | Description | Example | | ——- | ———————————– | ———————– | | Date | Calendar date | as.Date('2025-08-01') | | NA | Missing value | | | NULL | Empty object | | | (-) Inf | Positive or negative infinity | 1/0, -1/0 | | NaN | Not a Number: undefined mathematics | 0/0 | When working with dates, it is very handy to convert what is normally read as text (so “2025-01-01”) into Date because there is some additional functionality for resampling dates, and for plotting dates. The others, so NA, NULL, INF and NaN often show something is going wrong in the process, so watch out for these! 4.3 Converting between datatypes It is often necessary to convert data from one type to another. This process is called type conversion or casting. x &lt;- &quot;123&quot; num_x &lt;- as.numeric(x) print(num_x + 10) ## [1] 133 For conversion, watch out for these things: - NA introduction: if conversion fails, R returns an NA=&gt; as.numeric(\"hello\") - Loss of information: as.integer(3.99) will return 3, not 4! - Convering booleans: as.numeric(TRUE) returns and as.numeric(FALSE) returns 0 4.4 Data structures in R While it’s nice to be able to work with variables and single datapoints, more often than not we want to work with objects that include multiple data points, and sometimes even different datatypes. These we call data structures. In R, we have the following ones: Structure Description Example List Collection of any datatypes list1 = ['A', 1, TRUE] Vector Sequence of elements of the same datatype vector1 = c(1,2,3)vector2 = c('A','B','C') Matrix 2-Dimensional - vector: one object of strictly the same datatype matrix1 = matrix(1:6, nrow=2) Array Multi-Dimensional matrix equivalent Factor A special type of vector: one with categorical values.Internally, these values are then seen as a limited number of distinct groups (called levels) vector_levels = c('high','medium','high')factor1 = factor(vector_levels) Data frame Table-like structure with columns that can be mixed datatypes.A single column has one specific datatype The Data frame is particularly important. Any excel table that we open in R is put into a Data frame. 4.4.1 Vectors: The Building Blocks Vectors are the most fundamental data structure in R. Even when you assign a single number like x &lt;- 5, you’re actually creating a vector with one element! Here’s how to work with them: Creating vectors: # Numeric vector numbers &lt;- c(1, 2, 3, 4, 5) # Character vector names &lt;- c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;) # Logical vector results &lt;- c(TRUE, FALSE, TRUE, TRUE) # Using sequences sequence1 &lt;- 1:10 # Numbers 1 to 10 sequence2 &lt;- seq(0, 1, 0.1) # From 0 to 1 in steps of 0.1 Vector operations: One of R’s powerful features is vectorization - operations apply to entire vectors at once: numbers &lt;- c(1, 2, 3, 4) numbers * 2 # Multiply all elements by 2: (2, 4, 6, 8) ## [1] 2 4 6 8 numbers + c(10, 20, 30, 40) # Add corresponding elements: (11, 22, 33, 44) ## [1] 11 22 33 44 4.4.2 Lists: Mixed Data Collections Lists are like vectors but can hold different datatypes. Think of them as containers where each “slot” can hold anything: # Creating a list with mixed datatypes mixed_list &lt;- list( name = &quot;John&quot;, age = 25, married = TRUE, children = c(&quot;Emma&quot;, &quot;Liam&quot;) ) # You can also create lists without names simple_list &lt;- list(&quot;text&quot;, 42, TRUE) When to use lists vs vectors: Vectors: When all your data is the same type (all numbers, all text, etc.) Lists: When you need to store different types together, or when you want to store complex objects 4.4.3 Data Frames: The Excel of R Data frames are like Excel spreadsheets - they have rows and columns, where each column can be a different datatype but within a column, all values must be the same type. Creating a data frame: # Creating a simple data frame students &lt;- data.frame( name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;), age = c(20, 21, 19), grade = c(&quot;A&quot;, &quot;B&quot;, &quot;A+&quot;), passed = c(TRUE, TRUE, TRUE) ) print(students) ## name age grade passed ## 1 Alice 20 A TRUE ## 2 Bob 21 B TRUE ## 3 Charlie 19 A+ TRUE 4.4.4 Indexing: Accessing Your Data Once you have data stored in these structures, you need to be able to get specific pieces out. This is called indexing or subsetting. Position-based indexing (using square brackets []): # indexing - vectors numbers_vector &lt;- c(10, 20, 30, 40, 50) numbers_vector[1] # First element: 10 ## [1] 10 numbers_vector[3] # Third element: 30 ## [1] 30 numbers_vector[c(1, 3)] # First and third elements: 10, 30 ## [1] 10 30 # indexing - lists mixed_list &lt;- list(1, &quot;2&quot;, 6.7) mixed_list[1] # Returns a list containing just the name ## [[1]] ## [1] 1 mixed_list[2] ## [[1]] ## [1] &quot;2&quot; # indexing - data frame students &lt;- data.frame( name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;), age = c(20, 21, 19), grade = c(&quot;A&quot;, &quot;B&quot;, &quot;A+&quot;) ) # Matrix-style indexing [row, column] students[1, 2] # First row, second column: 20 ## [1] 20 students[1, ] # Entire first row ## name age grade ## 1 Alice 20 A students[, 2] # Entire second column (ages) ## [1] 20 21 19 students[1:2, c(&quot;name&quot;, &quot;age&quot;)] # First two rows, name and age columns ## name age ## 1 Alice 20 ## 2 Bob 21 # List-style indexing (by column) students$name # The name column ## [1] &quot;Alice&quot; &quot;Bob&quot; &quot;Charlie&quot; students[[&quot;age&quot;]] # The age column ## [1] 20 21 19 students[&quot;grade&quot;] # The grade column (returns data frame) ## grade ## 1 A ## 2 B ## 3 A+ # Logical indexing students[students$age &gt; 20, ] # All rows where age &gt; 20 ## name age grade ## 2 Bob 21 B students[students$grade == &quot;A&quot;, ] # All rows where grade is &quot;A&quot; ## name age grade ## 1 Alice 20 A Understanding these data structures and how to index them is crucial because almost everything you do in R involves manipulating data stored in these formats. Whether you’re reading a CSV file (which becomes a data frame), performing calculations (often on vectors), or organizing complex results (in lists), these concepts form the foundation of effective R programming. 4.5 Conditions and Comparisons One thing we often need to do with our datatypes, are comparisons. This is basically checking whether a statement is TRUE or FALSE. Here are the basic comparison operators in R: Operator Meaning Example Result   == Equal to 3 == 3 TRUE != Not equal to 3 != 5 TRUE &gt; Greater than 4 &gt; 2 TRUE &lt; Less than 4 &lt; 2 FALSE &gt;= Greater than or equal to 4 &gt;= 4 TRUE &lt;= Less than or equal to 4 &lt;= 3 FALSE %in% Element inside an object 1 %in% c(1,2) TRUE And for combining logical statements, we use operators, of which these are available: Operator Meaning Example Result &amp; AND TRUE &amp; FALSE FALSE | OR TRUE | FALSE TRUE ! NOT !FALSE TRUE 4.6 Conditional execution with Sometimes we only want to execute a piece of code under a certain condition. For that, we have what is called an if-statement. In R we write if (...comparison...){code to be executed}. The basic if statement: x &lt;- 4 if (x &gt; 0) { print(&quot;x is positive&quot;) } ## [1] &quot;x is positive&quot; Besides the if part, we can also add an else part, which will be executed if the comparison is FALSE. if ... else x &lt;- -1 if (x &gt; 0) { print(&quot;x is positive&quot;) } else { print(&quot;x is not positive&quot;) } ## [1] &quot;x is not positive&quot; 4.7 Repeating lines of code Sometimes, we want to execute a piece of code a certain number of times, or we want to execute the same code based on a bunch of different variables. We can repeat code using a for - loop. Basically, we write for (iteration) {code to be executed}. For example, let’s print the numbers 1 to 5. For that to be done, first we write a vector from 1 to 5, which we do through 1:5. Then we iterate through all the elements in that vector by: for (i in 1:5) { # for i = 1 until i = 5 print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 That was a classical example where we iterate through a bunch of integers. We can also iterate through other things: names = c(&#39;Marie Curie&#39;, &#39;Jenniffer Doudna&#39;, &#39;Alexander Flemming&#39;) for (name in names) { print(paste(name, &quot;won the Nobel Prize&quot;)) } ## [1] &quot;Marie Curie won the Nobel Prize&quot; ## [1] &quot;Jenniffer Doudna won the Nobel Prize&quot; ## [1] &quot;Alexander Flemming won the Nobel Prize&quot; 4.8 Functions People write code into functions in R. These are sometimes added into packages and published, so that anyone using R can use them. Examples of functions are paste(), log() (taking the logarithm base 10 of a number) and many others. When we make our own code, we sometimes end up writing huge chunks that we want to repeat, but can’t really put in a for loop. For that we can write our own functions! Here I’ll show an example testing whether or not our variable is negative or positive: positive_check &lt;- function(x) { # the name of the function is positive_or_negative, with the parameter &#39;x&#39; if (x &lt; 0) { # if x is smaller than 0 return(FALSE) # the output of the function is FALSE } else { # otherwise (if x is larger than, or equal to, 0) return(TRUE) # return TRUE } } And now that we’ve defined this function we can easily use it by positive_check(1), for example: positive_check(1) ## [1] TRUE positive_check(Inf) ## [1] TRUE "],["tidyverse.html", "Chapter 5 Tidyverse 5.1 Wide and tidy data 5.2 Data wrangling using dplyr 5.3 Data visualization using ggplot", " Chapter 5 Tidyverse The collection tidyverse includes some of the most widely used packages in R. Representing a collection of packages used for data cleaning, processing and visualization, every person familiar with R should know these packages! In this chapter we will be focussing on the implementation of the functions that make up the tidyverse, with a particular interest to data manipulation and visualization. The packages in tidyverse work on dataframes which we saw in the previous chapter. In particular, the tidyverse is made for tidy-dataframes. Following Wickman’s philosophy, a tidy dataframe is one with the following features: each variable is a column each observation is a row each value is a cell 5.1 Wide and tidy data Let’s go through an example together. Is the following table a tidy dataframe? # Column-wise matrix: male_cases, female_cases, year flu_cases &lt;- matrix( c(120, 150, # male_cases 100, 130, # female_cases 2020, 2021),# year nrow = 2, ncol = 3, byrow = FALSE # fill column-wise ) # Add column names colnames(flu_cases) &lt;- c(&quot;male_cases&quot;, &quot;female_cases&quot;, &quot;year&quot;) flu_cases &lt;- data.frame(flu_cases) flu_cases ## male_cases female_cases year ## 1 120 100 2020 ## 2 150 130 2021 The answer is no! Here, the variable sex is stored inside the column names instead of as a proper column. The tidyverse provides two key functions in the tidyr package to reshape data: pivot_longer() → makes data longer (good for tidy analysis, many rows, fewer columns) pivot_wider() → makes data wider (the opposite transformation, more columns, fewer rows) pivot_longer We can reshape our flu data into a tidy format: library(tidyr) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union flu_tidy &lt;- flu_cases %&gt;% pivot_longer( cols = c(male_cases, female_cases), names_to = &quot;sex&quot;, values_to = &quot;cases&quot; ) %&gt;% mutate(sex = ifelse(sex == &quot;male_cases&quot;, &quot;male&quot;, &quot;female&quot;)) flu_tidy ## # A tibble: 4 × 3 ## year sex cases ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2020 male 120 ## 2 2020 female 100 ## 3 2021 male 150 ## 4 2021 female 130 Now indeed each variable (year, sex, cases) has its own column. Tidy tables tend to be long, not wide — which is exactly what tidyverse functions expect. pivot_wider We can also go back to wide format: flu_wide_again &lt;- flu_tidy %&gt;% pivot_wider( names_from = sex, values_from = cases, names_glue = &quot;{sex}_cases&quot; ) flu_wide_again ## # A tibble: 2 × 3 ## year male_cases female_cases ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2020 120 100 ## 2 2021 150 130 Now we are back to the original table, where sex is encoded in the column names. 5.2 Data wrangling using dplyr There’s loads of functions within tidyverse. We will go through a couple of them together, using one of the default datasets in R, namely gapminder. This includes yearly observations per country in the world, of many variables as you’ll see. Then we’ll use what we learned on an epidemiological dataset to figure out the source of an outbreak! library(gapminder) head(gapminder) ## # A tibble: 6 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. pipeline-operator We connect different tidyverse functions using a so called pipeline operator: %&gt;%. We can write it like: new_dataframe = old_dataframe %&gt;% tidyverse_function select Using the function select() we select specific column names selected_columns = gapminder %&gt;% select(country, year, lifeExp) head(selected_columns) ## # A tibble: 6 × 3 ## country year lifeExp ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan 1952 28.8 ## 2 Afghanistan 1957 30.3 ## 3 Afghanistan 1962 32.0 ## 4 Afghanistan 1967 34.0 ## 5 Afghanistan 1972 36.1 ## 6 Afghanistan 1977 38.4 filter The filter function is a very powerful function that allows us to only keep the rows in our dataframe that fulfill a certain condition. See chapter … for more conditional logic in R, but here’s a couple of examples head(gapminder %&gt;% filter(year == 2007)) ## # A tibble: 6 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 2007 43.8 31889923 975. ## 2 Albania Europe 2007 76.4 3600523 5937. ## 3 Algeria Africa 2007 72.3 33333216 6223. ## 4 Angola Africa 2007 42.7 12420476 4797. ## 5 Argentina Americas 2007 75.3 40301927 12779. ## 6 Australia Oceania 2007 81.2 20434176 34435. head(gapminder %&gt;% filter(continent %in% c(&#39;Oceania&#39;, &#39;Africa&#39;))) ## # A tibble: 6 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Algeria Africa 1952 43.1 9279525 2449. ## 2 Algeria Africa 1957 45.7 10270856 3014. ## 3 Algeria Africa 1962 48.3 11000948 2551. ## 4 Algeria Africa 1967 51.4 12760499 3247. ## 5 Algeria Africa 1972 54.5 14760787 4183. ## 6 Algeria Africa 1977 58.0 17152804 4910. head(gapminder %&gt;% filter(pop &gt; 100000000)) ## # A tibble: 6 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Bangladesh Asia 1987 52.8 103764241 752. ## 2 Bangladesh Asia 1992 56.0 113704579 838. ## 3 Bangladesh Asia 1997 59.4 123315288 973. ## 4 Bangladesh Asia 2002 62.0 135656790 1136. ## 5 Bangladesh Asia 2007 64.1 150448339 1391. ## 6 Brazil Americas 1972 59.5 100840058 4986. mutate This is another very powerful and useful function. With mutate, we can change values in a dataframe. We can even change values in a dataframe that fulfill a certain condition. We do this by mutate(column_name = ...) if column_name doesn’t exist in the dataframe yet, a new column with this name is created. gapminder_pop_log = gapminder %&gt;% mutate(pop_log = log(pop)) gapminder_pop_log ## # A tibble: 1,704 × 7 ## country continent year lifeExp pop gdpPercap pop_log ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. 15.9 ## 2 Afghanistan Asia 1957 30.3 9240934 821. 16.0 ## 3 Afghanistan Asia 1962 32.0 10267083 853. 16.1 ## 4 Afghanistan Asia 1967 34.0 11537966 836. 16.3 ## 5 Afghanistan Asia 1972 36.1 13079460 740. 16.4 ## 6 Afghanistan Asia 1977 38.4 14880372 786. 16.5 ## 7 Afghanistan Asia 1982 39.9 12881816 978. 16.4 ## 8 Afghanistan Asia 1987 40.8 13867957 852. 16.4 ## 9 Afghanistan Asia 1992 41.7 16317921 649. 16.6 ## 10 Afghanistan Asia 1997 41.8 22227415 635. 16.9 ## # ℹ 1,694 more rows # some case_when functionality... Transmutate The function transmutate() does the same as mutate(), with the only difference being that exclusively the changed column is selected. Thus, transmutate() is a basically a combination of mutate %&gt;% select. Arrange The function arrange() does not actually change anything inside of hte dataframe, but only adjusts the order in which we see it. Based on one or more columns, the order of rows is changed. By default in ascending order (low to high). To change to descening values we add desc as follows # get the smallest popularion sizes in 1992 head(gapminder %&gt;% filter(year == 1992) %&gt;% arrange(pop)) ## # A tibble: 6 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Sao Tome and Principe Africa 1992 62.7 125911 1429. ## 2 Iceland Europe 1992 78.8 259012 25144. ## 3 Djibouti Africa 1992 51.6 384156 2377. ## 4 Equatorial Guinea Africa 1992 47.5 387838 1132. ## 5 Comoros Africa 1992 57.9 454429 1247. ## 6 Bahrain Asia 1992 72.6 529491 19036. # get the highest life expectancies in 2007 in Africa head(gapminder %&gt;% filter(year == 2007) %&gt;% filter(continent == &#39;Africa&#39;) %&gt;% arrange(desc(lifeExp))) ## # A tibble: 6 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Reunion Africa 2007 76.4 798094 7670. ## 2 Libya Africa 2007 74.0 6036914 12057. ## 3 Tunisia Africa 2007 73.9 10276158 7093. ## 4 Mauritius Africa 2007 72.8 1250882 10957. ## 5 Algeria Africa 2007 72.3 33333216 6223. ## 6 Egypt Africa 2007 71.3 80264543 5581. group_by The function group_by() allows us to group rows in a dataframe based on one or more columns. This does not yet change the dataframe values but rather sets up a grouped structure that works especially well with functions like summarise(). # group the data by continent gapminder %&gt;% group_by(continent) ## # A tibble: 1,704 × 6 ## # Groups: continent [5] ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. ## 7 Afghanistan Asia 1982 39.9 12881816 978. ## 8 Afghanistan Asia 1987 40.8 13867957 852. ## 9 Afghanistan Asia 1992 41.7 16317921 649. ## 10 Afghanistan Asia 1997 41.8 22227415 635. ## # ℹ 1,694 more rows Notice nothing much looks different yet — but now the data is grouped internally. To see its power, we usually combine it with summarise(). summarise The function summarise() (or summarize()) lets us reduce each group to one row by applying summary functions such as mean(), sum(), n() (count rows), etc. # average life expectancy per continent in 2007 gapminder %&gt;% filter(year == 2007) %&gt;% group_by(continent) %&gt;% summarise(mean_lifeExp = mean(lifeExp)) ## # A tibble: 5 × 2 ## continent mean_lifeExp ## &lt;fct&gt; &lt;dbl&gt; ## 1 Africa 54.8 ## 2 Americas 73.6 ## 3 Asia 70.7 ## 4 Europe 77.6 ## 5 Oceania 80.7 # total population per continent in 2007 gapminder %&gt;% filter(year == 2007) %&gt;% group_by(continent) %&gt;% summarise(total_pop = sum(pop)) ## # A tibble: 5 × 2 ## continent total_pop ## &lt;fct&gt; &lt;dbl&gt; ## 1 Africa 929539692 ## 2 Americas 898871184 ## 3 Asia 3811953827 ## 4 Europe 586098529 ## 5 Oceania 24549947 # combine multiple summaries gapminder %&gt;% filter(year == 2007) %&gt;% group_by(continent) %&gt;% summarise( mean_lifeExp = mean(lifeExp), sd_lifeExp = sd(lifeExp), total_pop = sum(pop), n_countries = n() ) ## # A tibble: 5 × 5 ## continent mean_lifeExp sd_lifeExp total_pop n_countries ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Africa 54.8 9.63 929539692 52 ## 2 Americas 73.6 4.44 898871184 25 ## 3 Asia 70.7 7.96 3811953827 33 ## 4 Europe 77.6 2.98 586098529 30 ## 5 Oceania 80.7 0.729 24549947 2 new functions: - rename - as.character/as.numeric/as.Date - across() - recode - case_when - replace_na - which() 5.3 Data visualization using ggplot "],["working-with-epidemiological-data.html", "Chapter 6 Working with epidemiological data 6.1 Acessing data 6.2 Case Study 1: Yellow Fever", " Chapter 6 Working with epidemiological data Data is at the heart of epidemiology. We look at where and when diseases occur, to hopefully better understand their origin or their cause, how to prevent or cure the disease, or to make predictions about the future. That’s why epidemiologists need to be able to work with disease data, and know how and where to look for it! That’s why in this chapter we go over some data-extraction, processing, visualization and analysis. We start simple, with an example of Yellow Fever, and then get into more complex case in which we try to understand cholera outbreaks. 6.1 Acessing data raw data cleaned data harmonization -&gt; standardization data cleaning: fixing or removing incorrect, incosistent or missing data data harmonziation: standardization or alignment of data ## (Imperfect) epidemiological data 6.2 Case Study 1: Yellow Fever Yellow fever (YF) is a severe and sometimes fatal hemorrhagic fever caused by a flavivirus with a single-stranded, negatively oriented RNA genome. It primarily affects regions in Africa and Latin America, where the virus sustains itself through a sylvatic cycle involving wild mosquitoes and non-human primates. In Brazil, for instance, mosquito species like Haemagogus and Sabethes maintain this cycle in forested areas. While a highly effective vaccine exists, yellow fever outbreaks still occur, particularly when the virus spills over into urban settings (Chippaux &amp; Chippaux, 2018). Historically, yellow fever was confined to Africa until the transatlantic slave trade introduced it to Latin America, where favorable climates and mosquito vectors allowed it to take root. Cities like New Orleans suffered repeated, devastating outbreaks in the past. Brazil saw a decline in cases mid-20th century, but a resurgence occurred between 2016 and 2018, with over 2,000 reported cases and a strikingly high death toll of 681. This resurgence was partly driven by the spread of the virus into urban areas, facilitated by Aedes aegypti and Aedes albopictus, mosquitoes that thrive in cities. Curiously, yellow fever has never established itself in Asia despite the presence of competent vectors and similar arboviruses, a mystery that may relate to immunological cross-reactivity with other flaviviruses like dengue (Chippaux &amp; Chippaux, 2018). The WHO has data data available for download for many different things, including casenumbers for many infectious diseases, including that for YF. The raw data for YF you can find here. I have cleaned this data a little so that the dataframe is as concise as possible, and so that all the countrynames correctly map to the ones in the world_shapefile dataset. 6.2.0.1 Installing packages library(scales) library(ggplot2) library(readr) ## ## Attaching package: &#39;readr&#39; ## The following object is masked from &#39;package:scales&#39;: ## ## col_factor library(glue) # The following packages print a lot of noise when installing so I silence their output # by wrapping them in a `suppressPackageStartupMessages({}) suppressPackageStartupMessages({ library(tidyverse) library(gapminder) library(rnaturalearth) library(rnaturalearthdata) library(sf) }) 6.2.0.2 Installing world shapedata Eventually, I want to show you how to make some plots and some maps. For that, we need to load the shape of the world, so that we can fill in countries with certain colors and such. For that we’ll load the world shapefile from the package rnaturalearth. This dataset includes many different columns, but we only require some of them; name, geometry and continent. world_shapefile = ne_countries(scale = &quot;medium&quot;, returnclass = &quot;sf&quot;) %&gt;% select(c(&quot;name&quot;,&quot;geometry&quot;, &quot;continent&quot;)) colnames(world_shapefile)[1] = c(&quot;country&quot;) continents_list = unique(world_shapefile$continent) countries_continents &lt;- world_shapefile %&gt;% st_set_geometry(NULL) %&gt;% select(country, continent) # World map ggplot(world_shapefile) + geom_sf(aes(fill = continent), color = &quot;black&quot;, linewidth = 0.01) + theme_minimal(base_size = 14) + labs( title = &#39;world shapefile&#39;, ) + theme( panel.background = element_rect(fill = &quot;#f7f9fc&quot;), legend.position = &quot;right&quot;, plot.title = element_text(face = &quot;bold&quot;, size = 16), plot.subtitle = element_text(size = 12) ) 6.2.0.3 Yellow Fever data who_yellowfever = read_csv(&quot;data/cleaned_yellowfever.csv&quot;, show_col_types = FALSE) # head allows us to preview the table head(who_yellowfever) ## # A tibble: 6 × 3 ## country year cases ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Algeria 2024 0 ## 2 Andorra 2024 0 ## 3 Anguilla 2024 0 ## 4 Antigua and Barb. 2024 0 ## 5 Armenia 2024 0 ## 6 Aruba 2024 0 # draw up some specifications of the dataset n_countries = length(unique(who_yellowfever$country)) first_year = min(who_yellowfever$year) last_year = max(who_yellowfever$year) glue(&quot;\\nThe dataframe contains yearly casedata for {n_countries} countries between {first_year} and {last_year}&quot;) ## The dataframe contains yearly casedata for 212 countries between 1974 and 2024 6.2.0.4 Global yearly cases Let’s first get a global overview of YF in the world the past 50 years. To start with, we will create a graph showing the number of cases in the world per year, and then we’ll show it per continent to see which are the ones most affected. # Global epicurve global_yearly_casenumbers &lt;- who_yellowfever %&gt;% group_by(year) %&gt;% summarise(cases = sum(cases)) ggplot(global_yearly_casenumbers) + geom_line(aes(x = year, y = cases), color = &#39;black&#39;, linewidth = 1.5) + # black outline geom_line(aes(x = year, y = cases), color = &#39;#ffcc00&#39;, linewidth = 1) + # yellow line scale_x_continuous(breaks = pretty_breaks(n = 20)) + # I don&#39;t want a break per year. I do a max of 20 year theme_classic(base_size = 14) + labs( x = &quot;&quot;, title = &quot;Yellow Fever Cases in the world 1974 - 2024&quot;, subtitle = &quot;number of cases reported to the WHO&quot; ) 6.2.0.5 Yearly cases per continent yearly_casenumbers_continent = merge(who_yellowfever, countries_continents, by = &quot;country&quot;) %&gt;% group_by(year, continent) %&gt;% summarise(cases = sum(cases), .groups = &quot;drop&quot;) %&gt;% filter(continent %in% continents_list) ggplot(yearly_casenumbers_continent) + geom_line(aes(x = year, y = cases, color = continent), linewidth = 1.5) + scale_x_continuous(breaks = pretty_breaks(n = 20)) + theme_classic(base_size = 14) + scale_color_brewer(palette = &quot;Dark2&quot;) + # 7 distinct colors labs( x = &quot;&quot;, title = &quot;Yellow Fever Cases in the world 1973 - 2024 per continent&quot;, subtitle = &quot;number of cases reported to the WHO&quot; ) + theme(legend.position = &quot;bottom&quot;) We can clearly tell that since 1974, Africa has experienced the largest burden by YF, though South America suffered between 2016 and 2019 as well. Let’s have a look at the total sum of cases per country in the past, to see which countries and which areas are affected the most. 6.2.0.6 Historical burden cases_per_country = who_yellowfever%&gt;% group_by(country) %&gt;% summarise(cases = sum(cases)) mapdata = st_as_sf(merge(cases_per_country, world_shapefile, on = &#39;country&#39;, all.y = TRUE)) mapdata$cases_category &lt;- cut( mapdata$cases, breaks = c(0,100, 500, 1000, 2000, 5000, 10000, 20000, Inf), # 8 breaks → 7 intervals labels = c(&quot;0 - 100&quot;, &quot;101-500&quot;,&quot;501-1000&quot;, &quot;1001-2000&quot;, &quot;2001-5000&quot;, &quot;5001-10000&quot;, &quot;10001-20000&quot;, &quot;&gt;20000&quot;), include.lowest = TRUE ) pl &lt;- ggplot(mapdata) + geom_sf(aes(fill = cases_category), color = &quot;black&quot;, size = 0.1) + scale_fill_brewer(palette = &quot;YlOrRd&quot;, na.value = &quot;gray95&quot;, name = &quot;Cases&quot;) + theme_minimal(base_size = 14) + theme( panel.background = element_rect(fill = &quot;#E0FFFF&quot;), # clean light background legend.position = &quot;right&quot;, plot.title = element_text(face = &quot;bold&quot;, size = 16), plot.subtitle = element_text(size = 12) ) + labs(title = &#39;Cumulative cases 1974 - 2024&#39;) pl From this we can clearly see that the most affected regions are central and west Africa, as well as central(?) Latin America. This does not allow us to look into temporal dynamics though, so let’s look a bit further into that using a function. 6.2.0.7 Country-specific epicurves plot_country = function(country_filter){ filtered_df &lt;- who_yellowfever %&gt;% filter(country == country_filter) pl = ggplot(filtered_df) + geom_line(aes(x = year, y = cases), color = &#39;black&#39;, linewidth = 1.5) + # black outline geom_line(aes(x = year, y = cases), color = &#39;#ffcc00&#39;, linewidth = 1) + # yellow line geom_point(aes(x = year, y = cases), color = &#39;black&#39;, linewidth = 1) + # black outline scale_x_continuous(breaks = pretty_breaks(n = 20)) + theme_classic(base_size = 14) + labs(x = &quot;&quot;, y=&#39;cases&#39;) + labs( title = paste0(&quot;Yellow Fever Cases in &quot;, country_filter, &quot; 1973 - 2024&quot;), subtitle = &quot;number of cases reported to the WHO&quot; ) return(pl) } plot_country(&quot;Dem. Rep. Congo&quot;) ## Warning in geom_point(aes(x = year, y = cases), color = &quot;black&quot;, linewidth = ## 1): Ignoring unknown parameters: `linewidth` plot_country(&quot;Chad&quot;) ## Warning in geom_point(aes(x = year, y = cases), color = &quot;black&quot;, linewidth = ## 1): Ignoring unknown parameters: `linewidth` plot_country(&quot;Nigeria&quot;) ## Warning in geom_point(aes(x = year, y = cases), color = &quot;black&quot;, linewidth = ## 1): Ignoring unknown parameters: `linewidth` plot_country(&quot;Ghana&quot;) ## Warning in geom_point(aes(x = year, y = cases), color = &quot;black&quot;, linewidth = ## 1): Ignoring unknown parameters: `linewidth` plot_country(&quot;Brazil&quot;) ## Warning in geom_point(aes(x = year, y = cases), color = &quot;black&quot;, linewidth = ## 1): Ignoring unknown parameters: `linewidth` plot_country(&quot;Peru&quot;) ## Warning in geom_point(aes(x = year, y = cases), color = &quot;black&quot;, linewidth = ## 1): Ignoring unknown parameters: `linewidth` This is actually already interesting! We can see that some many of these countries have very big outbreaks in a specific year, or over a couple of years, while a peak in one country doesn’t necessarily translate in one elsewhere. Peru, for example, had a big outbreak in 1995, and hasn’t had many cases since. Brazil, however, did not report manby cases until 2017 when it detected a huge outbreak that lasted until 2018. "],["modelling.html", "Chapter 7 Modelling 7.1 Compartmental models 7.2 Time series - Forecasting 7.3 Using and applying models", " Chapter 7 Modelling 7.1 Compartmental models 7.1.1 SIR model in theory Compartmental models divide a population into distinct groups, or compartments, each governed by specific rules that describe how individuals move between compartments over time. In epidemiology, one of the most common models is the SIR model, which divides the population into three compartments: Susceptible (S): individuals who can contract the disease Infectious (I): individuals who are currently infected and can transmit the disease Recovered (R): individuals who have recovered and are no longer infectious Individuals move from S to I (when infected), and from I to R (when they recover). This progression can be described using either discrete-time or continuous-time equations. 7.1.1.1 Discrete-Time Formulation The discrete-time version of the SIR model is expressed as: \\[ \\begin{aligned} S_{t+1} &amp;= S_t - \\beta S_t I_t \\\\ I_{t+1} &amp;= I_t + \\beta S_t I_t - \\gamma I_t \\\\ R_{t+1} &amp;= R_t + \\gamma I_t \\end{aligned} \\] Here, \\(S_{t+1}\\) is the number of susceptible individuals at the next time step, determined by subtracting those who become infected. \\(I_{t+1}\\) increases with new infections and decreases as people recover. \\(R_{t+1}\\) increases with recoveries. 7.1.1.2 Continuous-Time Formulation (ODEs) For more refined, continuous-time modeling, we use ordinary differential equations: \\[ \\begin{aligned} \\frac{dS}{dt} &amp;= -\\beta S I \\\\ \\frac{dI}{dt} &amp;= \\beta S I - \\gamma I \\\\ \\frac{dR}{dt} &amp;= \\gamma I \\end{aligned} \\] These represent the rate of change of each compartment over time. Where: - \\(\\beta\\) is the transmission rate - \\(\\gamma\\) is the recovery rate - \\(N = S + I + R\\) is the total population 7.1.2 SIR model in R Despite its simplicity, the SIR model can be surprisingly effective. During the COVID-19 pandemic, many government advisors based their projections on variations of this basic framework. As an example, consider an influenza outbreak that occurred in 1978 at a boarding school in England. The on-site physician documented how many students were sick (in bed) and how many were recovering (convalescent) each day. This dataset is included in the outbreaks R package, allowing us to study it directly. library(outbreaks) data(&quot;influenza_england_1978_school&quot;) outbreak_data &lt;- influenza_england_1978_school head(outbreak_data) ## date in_bed convalescent ## 1 1978-01-22 3 0 ## 2 1978-01-23 8 0 ## 3 1978-01-24 26 0 ## 4 1978-01-25 76 0 ## 5 1978-01-26 225 9 ## 6 1978-01-27 298 17 outbreak_data_long &lt;- pivot_longer(outbreak_data, cols = c(in_bed, convalescent), names_to = &quot;group&quot;, values_to = &quot;count&quot;) ggplot(outbreak_data_long, aes(x = date, y = count, color = group)) + geom_line(linewidth = 1.2) + geom_point(color = &quot;black&quot;, size = 2) + scale_x_date(breaks = outbreak_data_long$date, date_labels = &quot;%b %d&quot;) + labs(title = &quot;Influenza Outbreak (1978 Boarding School)&quot;, x = &quot;&quot;, y = &quot;Number of Students&quot;, color = &quot;Status&quot;) + theme_minimal() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) Now let’s implement the SIR model in R: sir_model &lt;- function(number_of_days, BETA, GAMMA, dt = 1) { N &lt;- 763 I0 &lt;- 1 S0 &lt;- N - I0 R0 &lt;- 0 times &lt;- seq(0, number_of_days, by = dt) n_steps &lt;- length(times) sirdata &lt;- data.frame( t = times, S = numeric(n_steps), I = numeric(n_steps), R = numeric(n_steps) ) sirdata[1, ] &lt;- c(0, S0, I0, R0) for (tt in 2:n_steps) { S_prev &lt;- sirdata$S[tt - 1] I_prev &lt;- sirdata$I[tt - 1] R_prev &lt;- sirdata$R[tt - 1] new_infections &lt;- BETA * S_prev * I_prev * dt new_recoveries &lt;- GAMMA * I_prev * dt new_infections &lt;- min(new_infections, S_prev) new_recoveries &lt;- min(new_recoveries, I_prev) S_new &lt;- S_prev - new_infections I_new &lt;- I_prev + new_infections - new_recoveries R_new &lt;- R_prev + new_recoveries sirdata[tt, ] &lt;- c(times[tt], S_new, I_new, R_new) } return(sirdata) } output = sir_model(14, 0.0026, 0.565, 0.1) sirdata_long = pivot_longer(output, cols = c(&quot;S&quot;, &quot;I&quot;, &quot;R&quot;), names_to = &quot;compartment&quot;, values_to = &quot;count&quot;) ggplot(sirdata_long, aes(x = t, y = count, color = compartment)) + geom_line(linewidth = 1.2) + labs(title = &quot;Influenza Outbreak (1978 Boarding School)&quot;, x = &quot;&quot;, y = &quot;Number of Students&quot;, color = &quot;Status&quot;) + theme_minimal() Let’s now compare the observed in_bed data with the simulated number of infectious individuals: sir_output &lt;- sir_model(14, 0.0026, 0.565, dt = 0.1) sir_daily &lt;- sir_output %&gt;% group_by(day = floor(t)) %&gt;% summarize(I_simulated = mean(I)) observed_data &lt;- outbreak_data %&gt;% mutate(day = as.numeric(date - min(date))) %&gt;% select(day, in_bed) plot_data &lt;- left_join(observed_data, sir_daily, by = &quot;day&quot;) %&gt;% pivot_longer(cols = c(in_bed, I_simulated), names_to = &quot;type&quot;, values_to = &quot;count&quot;) ggplot(plot_data, aes(x = day, y = count, color = type)) + geom_line(linewidth = 1.2) + geom_point(size = 2, alpha = 0.8) + scale_x_continuous(breaks = 0:max(plot_data$day)) + labs(title = &quot;Observed vs Simulated Infections&quot;, x = &quot;Days Since Outbreak Start&quot;, y = &quot;Number of Students&quot;, color = &quot;Data Type&quot;) + theme_minimal() + theme(axis.text.x = element_text(angle = 0)) 7.2 Time series - Forecasting Forecasting plays a crucial role in infectious disease epidemiology by enabling short-term projections of case counts. These projections help guide timely public health decisions, especially when diseases exhibit seasonal or trend-driven behavior. In this section, we compare two popular time series approaches: Holt-Winters exponential smoothing, which models level, trend, and seasonality using exponentially weighted averages. ARIMA (AutoRegressive Integrated Moving Average), a flexible class of models that can account for autoregressive lags, differencing (trends), and moving average components, including seasonal extensions (SARIMA). Unlike mechanistic models (e.g., SIR), these statistical methods do not rely on assumptions about transmission mechanisms. Instead, they learn from the patterns and structure of historical data to forecast future values. We apply both models to weekly national tick-borne encephalitis (TBE) cases and generate forecasts for the year following a specified historical cutoff. library(dplyr) library(ggplot2) library(forecast) ## Registered S3 method overwritten by &#39;quantmod&#39;: ## method from ## as.zoo.data.frame zoo library(lubridate) library(patchwork) # --- Load and preprocess data --- tbe_local &lt;- read.csv(&quot;data/tick_borne_encephalitis.csv&quot;) tbe_national &lt;- tbe_local %&gt;% mutate(timestamp = as.Date(timestamp)) %&gt;% group_by(timestamp) %&gt;% summarise(cases = sum(cases), .groups = &quot;drop&quot;) # --- Forecasting setup --- year &lt;- 2018 # Change to define cutoff year tbe_national_context &lt;- tbe_national %&gt;% filter(year(timestamp) &lt;= year) tbe_national_future &lt;- tbe_national %&gt;% filter(year(timestamp) == year + 1) %&gt;% arrange(timestamp) # ---- Create time series object ---- context_ts &lt;- ts(tbe_national_context$cases, frequency = 52) # ---- Holt-Winters model ---- hw_model &lt;- HoltWinters(context_ts) forecast_hw &lt;- forecast(hw_model, h = 52) predicted_df_hw &lt;- data.frame( timestamp = seq.Date(from = as.Date(paste0(year + 1, &quot;-01-01&quot;)), by = &quot;week&quot;, length.out = 52), cases = as.numeric(forecast_hw$mean), type = &quot;predicted_hw&quot; ) # ---- ARIMA model ---- arima_model &lt;- auto.arima(context_ts, seasonal = TRUE) forecast_arima &lt;- forecast(arima_model, h = 52) predicted_df_arima &lt;- data.frame( timestamp = seq.Date(from = as.Date(paste0(year + 1, &quot;-01-01&quot;)), by = &quot;week&quot;, length.out = 52), cases = as.numeric(forecast_arima$mean), type = &quot;predicted_arima&quot; ) # ---- Combine all data for plotting ---- context_labeled &lt;- tbe_national_context %&gt;% mutate(type = &quot;historical&quot;) future_labeled &lt;- tbe_national_future %&gt;% mutate(type = &quot;observed&quot;) combined_data &lt;- bind_rows(context_labeled, future_labeled, predicted_df_hw, predicted_df_arima) # ---- Plot full timeline ---- main_plot &lt;- ggplot(combined_data, aes(x = timestamp, y = cases, color = type)) + geom_line(linewidth = 1.2) + scale_color_manual(values = c( &quot;historical&quot; = &quot;#1f77b4&quot;, &quot;observed&quot; = &quot;#2ca02c&quot;, &quot;predicted_hw&quot; = &quot;#d62728&quot;, &quot;predicted_arima&quot; = &quot;#ff7f0e&quot; )) + theme_classic() + labs( title = paste(&quot;TBE Weekly Cases: Forecasting&quot;, year + 1), x = &quot;Time&quot;, y = &quot;Cases&quot;, color = &quot;Data Type&quot; ) + theme( legend.position = &quot;top&quot;, plot.title = element_text(face = &quot;bold&quot;, size = 16) ) # ---- Plot zoomed forecast year ---- zoom_plot &lt;- combined_data %&gt;% filter(year(timestamp) == year + 1) %&gt;% ggplot(aes(x = timestamp, y = cases, color = type)) + geom_line(linewidth = 1.2) + scale_color_manual(values = c( &quot;historical&quot; = &quot;#1f77b4&quot;, &quot;observed&quot; = &quot;#2ca02c&quot;, &quot;predicted_hw&quot; = &quot;#d62728&quot;, &quot;predicted_arima&quot; = &quot;#ff7f0e&quot; )) + theme_classic() + labs( title = paste(&quot;Zoom: Forecasts vs Observed in&quot;, year + 1), x = &quot;Week&quot;, y = &quot;Cases&quot; ) + theme( legend.position = &quot;none&quot;, plot.title = element_text(face = &quot;bold&quot;) ) # ---- Combine and show ---- main_plot / zoom_plot + plot_layout(heights = c(2, 1)) This analysis demonstrates how different statistical forecasting methods—Holt-Winters vs ARIMA—perform on the same epidemiological time series. While Holt-Winters is intuitive and captures seasonality well, ARIMA can offer greater flexibility in modeling autocorrelated structures. Comparing their predictions side-by-side allows us to evaluate model fit and choose an approach best suited for early warning or planning systems. 7.3 Using and applying models "],["communication-and-sharing-of-code-and-data.html", "Chapter 8 Communication and sharing of code and data 8.1 Writing code: best practices 8.2 Github 8.3 Reports using Markdown 8.4 Open science 8.5 Communities and forums 8.6 How to use Chat-GPT", " Chapter 8 Communication and sharing of code and data 8.1 Writing code: best practices 8.2 Github 8.3 Reports using Markdown 8.4 Open science 8.5 Communities and forums 8.6 How to use Chat-GPT "],["recommended-reading.html", "Chapter 9 Recommended Reading 9.1 Recommended textbooks and courses 9.2 Useful packages", " Chapter 9 Recommended Reading 9.1 Recommended textbooks and courses https://epirhandbook.com/en/new_pages/ggplot_basics.html: great pieces on ggplot (chapter 30) ## Datasources 9.2 Useful packages "],["references.html", "References", " References Chippaux, J. P., &amp; Chippaux, A. (2018). Yellow fever in africa and the americas: A historical and epidemiological perspective. Journal of Venomous Animals and Toxins Including Tropical Diseases, 24. https://doi.org/10.1186/s40409-018-0162-y "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
