[["index.html", "Epibible Epibible", " Epibible Sten de Schrijver 2025-08-21 Epibible "],["preface.html", "Preface", " Preface Hi, and welcome! I truly appreciate you taking the time to look over this work of mine. This digital book is designed to serve as a reference covering essential concepts that everyone working in epidemiology should know. We will explore some (minimal) theoretical epidemiology and examine various epidemiological concepts through real-world disease scenarios. After introducing how R works and how it can be applied across many areas of public health, we will discuss how to access and manage epidemiological data. Finally, we’ll bring everything together so that, regardless of your background, you’ll gain a solid foundational experience in epidemiology using R, enabling you to confidently dive deeper into this fascinating field. Public health is a prime example of a multidisciplinary arena where diverse scientific fields converge. The One Health approach, in particular, not only connects different disciplines but also encourages multiple perspectives on the same issue. For example, a medical doctor may view a mosquito as a vector transmitting disease, while an ecologist might see it as an invasive species indicating changing habitat suitability, perhaps due to global warming. Although One Health experts recognize the importance of interdisciplinary collaboration and education, this integration often falls short when it comes to computers and data. This is precisely the gap this material aims to bridge. While this reader covers fundamental topics in epidemiology and R, it will gradually expand to include more advanced and diverse content of interest to a wide audience. For readers already familiar with R and data analysis, I will occasionally provide suggestions for further reading, highlight useful R packages, and touch upon emerging fields where epidemiology intersects with disciplines like machine learning. As this is a first draft intended as background material for a future course, I warmly welcome your feedback! Please feel free to share your thoughts by emailing me. "],["about-the-author.html", "About the Author", " About the Author As a graduate from a bachelor’s degree in Nanobiology (joint degree of the Techinical University in Delft and ERasmus Medical School, the Netherlands) and the MSc. Erasmus Mundus Joint Degree in Infectious Diseases and One Health, I have a solid background in molecular biology, infection biology, public health, epidemiology and data analytics. The fields specifically, I am now integrating on a daily basis during my PhD (Robert Koch Institut, Berlin) in artificial intelligence in public health. On a daily basis I look at the prevalence of vaccine-preventable diseases, and try to model dynamics and occurances of these diseases. During my studies, I have seen that people understand more and more the necessity of learning different skills from different fields, to become a more “well - rounded” scientist. While advocating for this, I have also experienced the hesitancy of both students and specialists to take up new skills of the digital and the mathematical area. Especially in the information age that we live in, I find it inexcplicable that students graduating from degrees in public health have practically no experience with working with data. "],["introduction-to-epidemiology.html", "Chapter 1 Introduction to Epidemiology", " Chapter 1 Introduction to Epidemiology I still need to look into this. "],["working-with-this-book.html", "Chapter 2 Working with this book 2.1 What is bookdown? 2.2 What is Markdown 2.3 Code snippets 2.4 Other formats in this book", " Chapter 2 Working with this book Before diving into the coding content, this chapter explains how this book is organized and how you can make th;e most of the examples and code snippets provied throughout this book. 2.1 What is bookdown? This book is written using bookdown, a pakage in R that helps create digital books and long-form documents using R Markdown. Bookdowns allow us to do multiple things, in one clean and organized document: combine text and executable R code in one place automatically generates formatted output like HTML, PDF or e-books Cross-reference chapters, figures tables and equations provide code snippets that any reader can copy paste into executable code chunks for easy practice. 2.2 What is Markdown The continent you see here is written in Markdown, a simple plain-text formatting syntax that’s easy to write and read. Markdown allows you to add: Headings and subheadings Formatted text (bold, italic) 2.3 Code snippets Throughout this book you will find code chunks like the one on the next few lines. In grey and italic you will see comments, denoted by starting with a hashtag (‘#’). Any normal looking text is executable code. Upon generation of this bookdown, all code chunks that are written are executed. Below each chunk, you find another grey background box, which holds the output of that chunk. # This is a comment print(&quot;this is executable code!&quot;) ## [1] &quot;this is executable code!&quot; Because these chunks are literally the code that I have written myself, you can simply copy paste this into your system, and thereby run the same code. 2.4 Other formats in this book There’s a few common text-formats. I’ll be using these: bold: terminology italic: variables in functions inline code: functions "],["getting-started-with-r.html", "Chapter 3 Getting Started with R 3.1 Installing R and Rstudio 3.2 Starting to code", " Chapter 3 Getting Started with R 3.1 Installing R and Rstudio R is not a computer program like Microsoft Word. Instead, it is a computer language, just like Python, Matlab, Java and many others. You can tell your computer to execute commands, by writing the commands in such a computer language. RStudio is an interface, an application, that functions as a tool to help you write, understand and organize your R code. In order to get R up and running on your system we therefore need to install both R and Rstudio. Follow the steps on this website specifically for your system (Linux, Mac, Windows). After installation, you can open the application RStudio and in it run Rcode. You’ll notice 4 sections in RStudio: script editor (top left); this is where we will do most work. We will write and edit code in this place console (bottom left); this is where we execute code. while you can run R commands here directly, we will execute code here written in the script editor. environment pane (top right); shows all the current variables, datasets and anything else in the working memory file pane (bottom right); allows you to browse overfiles The R language is incredibly large and diverse. Any user of R can extend the language with new functions and new tools, which come together in the shape of a package. There are about 20 thousand (!) R packages available, each of which has their own speciality. When some clever person creates a new epidemiological model and wants it to become available for the community, they can upload it on R and make it available for us. While the volume of packages make it sound like you can easily lose track of everything that’s out there, there’s only a handful of packages that really everyone tends to use. For example, the Tidyverse is a collection of packages that many people workign with R have experience with. We will also be using it a lot in this course, specifically the packages ggplot2 (for visualization) dplyr (for data manipulation), readr (for reading datafiles) and tidyr (for reshaping dataframes). We will go through installing and loading packages, and writing functions later in this course. For now we can get started on some very simple things in R, to get you familiar with doing some coding! 3.2 Starting to code The print() function is a very basic and useful one, which allows you to often check some things quickly. On the first line in the script editor, go and write the following line: print(&#39;hello world!&#39;) ## [1] &quot;hello world!&quot; with your cursor on the right side of that line, press the “run”-button. You will see the output in the console where it now shows in yellow what has been executed, and in white the output is shown. R is great for doing some easy mathematics. Let’s do some calculations and print the output: x = 10 y = 280 z = 0.4 product = x*y*z print(product) ## [1] 1120 Here we have multiple lines of code, that we need to execute in that order for it to work. We can’t first run the print, and then do the calculations. We can either do that line by line, so press the run button each time. Alternatively, you can select all these lines, and then press the run button. Another option is to use the shortcut (Windows?) CTRL + Enter. This is the equivalent of the Run button. So select all the lines, and press CTRL + Enter We will discuss more R syntax, and more thigns to code, at a later point. For now let’s leave it at this and talk a bit about how we organize our code. ## R Projects and Organization We can save our code in an R script, which is the most basic R file. To do that, we go CTR + S and can navigate to the location to save our file. Besides this R file (extension: .R) we have a couple of other options, including an R Markdown. I am a huge fan of these. If you’re familiar with Python; R Markdown - files are the R equivalent of a jupyter notebook file. They allow you to write code in the same file as nicely organized text. You can put in graphs that look really nice, add citations and a bibliography, add chapters, and so much more. This whole textbook is actually running in a handful of R Markdown files. Eventually, I want to write a small project with you in an R Markdown as well, though for now we can get started with R scripts. To organize our R code properly, we shouldn’t work with individual R scripts. It is much better to have a specific environment for your R code, in which you store your analysis (code), your data and your results and figures. Something I struggle a lot with myself is with directories. A directory is a certain folder’s location, a way of pinpointing where R is working (the workign directory). This is important to know, because when we tell R where to find a certain dataset on our computer, the computer needs to know the starting point of our trip. To fix all these issues, we have something called an R project. This is exactly an environment to bundle different R files in a seperate folder, where the working directory is atuomatically set to the root of the project; the location of the project file. We create an R project through the following steps: File &gt; New Project A window will pop up asking to Save the current workspace: - Don’t save New Directory &gt; New Project In Directory name: write “epiproject_00” In Create project as a subdirectory of: - press browse, and navigate to a place on hyour computer you would like to store your R codes. I suggest this NOT TO BE your Downloads or Desktop folder. Create Project Now that we’re in a project, open a new R script. Save it in the project under the name “00_syntax” and let’s set started in the next chapter. "],["r-fundamentals.html", "Chapter 4 R fundamentals 4.1 Basic Datatypes in R 4.2 Special datatypes 4.3 Converting between datatypes 4.4 Data structures in R 4.5 Conditions and Comparisons 4.6 Conditional execution with 4.7 Repeating lines of code 4.8 Functions", " Chapter 4 R fundamentals 4.1 Basic Datatypes in R When coding, we work with variables. Say we start our code with x=1, then x is a variable. We can do some calculations with x, and we can change x, depending on the type of data that the variable is. In R, variables can represent the following datatypes: Type Description Example Numeric Real number 3.14, -6.7 Integer Whole number 1, 4, 16 Character Text or string a, hello! Logical Boolean TRUE, FALSE The specification of a datatype is very important. While some datatypes may allow certain functionality, others may not. We can sum two numeric variables, which we can also do for two integers. When we try to add two characters to each other though, R will throw an error. Have a look yourself. summing two numeric datatypes x = 1.1 y = 2.9 print(x+y) ## [1] 4 summing two characters text1 = &#39;hello&#39; text2 = &#39;there!&#39; # print(text1+text2) -&gt; this will throw an error! While this doesn’t work, there are ways of combining, or rather concatenating two strings, namely using paste() and paste0(): paste(text1, text2) ## [1] &quot;hello there!&quot; paste0(text1, text2) ## [1] &quot;hellothere!&quot; 4.2 Special datatypes Besides the basic types of variables mentioned below, R also supports some special datatypes: | Type | Description | Example | | ——- | ———————————– | ———————– | | Date | Calendar date | as.Date('2025-08-01') | | NA | Missing value | | | NULL | Empty object | | | (-) Inf | Positive or negative infinity | 1/0, -1/0 | | NaN | Not a Number: undefined mathematics | 0/0 | When working with dates, it is very handy to convert what is normally read as text (so “2025-01-01”) into Date because there is some additional functionality for resampling dates, and for plotting dates. The others, so NA, NULL, INF and NaN often show something is going wrong in the process, so watch out for these! 4.3 Converting between datatypes It is often necessary to convert data from one type to another. This process is called type conversion or casting. x &lt;- &quot;123&quot; num_x &lt;- as.numeric(x) print(num_x + 10) ## [1] 133 For conversion, watch out for these things: - NA introduction: if conversion fails, R returns an NA=&gt; as.numeric(\"hello\") - Loss of information: as.integer(3.99) will return 3, not 4! - Convering booleans: as.numeric(TRUE) returns and as.numeric(FALSE) returns 0 4.4 Data structures in R While it’s nice to be able to work with variables and single datapoints, more often than not we want to work with objects that include multiple data points, and sometimes even different datatypes. These we call data structures. In R, we have the following ones: Structure Description Example List Collection of any datatypes list1 = ['A', 1, TRUE] Vector Sequence of elements of the same datatype vector1 = c(1,2,3)vector2 = c('A','B','C') Matrix 2-Dimensional - vector: one object of strictly the same datatype matrix1 = matrix(1:6, nrow=2) Array Multi-Dimensional matrix equivalent Factor A special type of vector: one with categorical values.Internally, these values are then seen as a limited number of distinct groups (called levels) vector_levels = c('high','medium','high')factor1 = factor(vector_levels) Data frame Table-like structure with columns that can be mixed datatypes.A single column has one specific datatype The Data frame is particularly important. Any excel table that we open in R is put into a Data frame. 4.4.1 Vectors: The Building Blocks Vectors are the most fundamental data structure in R. Even when you assign a single number like x &lt;- 5, you’re actually creating a vector with one element! Here’s how to work with them: Creating vectors: # Numeric vector numbers &lt;- c(1, 2, 3, 4, 5) # Character vector names &lt;- c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;) # Logical vector results &lt;- c(TRUE, FALSE, TRUE, TRUE) # Using sequences sequence1 &lt;- 1:10 # Numbers 1 to 10 sequence2 &lt;- seq(0, 1, 0.1) # From 0 to 1 in steps of 0.1 Vector operations: One of R’s powerful features is vectorization - operations apply to entire vectors at once: numbers &lt;- c(1, 2, 3, 4) numbers * 2 # Multiply all elements by 2: (2, 4, 6, 8) ## [1] 2 4 6 8 numbers + c(10, 20, 30, 40) # Add corresponding elements: (11, 22, 33, 44) ## [1] 11 22 33 44 4.4.2 Lists: Mixed Data Collections Lists are like vectors but can hold different datatypes. Think of them as containers where each “slot” can hold anything: # Creating a list with mixed datatypes mixed_list &lt;- list( name = &quot;John&quot;, age = 25, married = TRUE, children = c(&quot;Emma&quot;, &quot;Liam&quot;) ) # You can also create lists without names simple_list &lt;- list(&quot;text&quot;, 42, TRUE) When to use lists vs vectors: Vectors: When all your data is the same type (all numbers, all text, etc.) Lists: When you need to store different types together, or when you want to store complex objects 4.4.3 Data Frames: The Excel of R Data frames are like Excel spreadsheets - they have rows and columns, where each column can be a different datatype but within a column, all values must be the same type. Creating a data frame: # Creating a simple data frame students &lt;- data.frame( name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;), age = c(20, 21, 19), grade = c(&quot;A&quot;, &quot;B&quot;, &quot;A+&quot;), passed = c(TRUE, TRUE, TRUE) ) print(students) ## name age grade passed ## 1 Alice 20 A TRUE ## 2 Bob 21 B TRUE ## 3 Charlie 19 A+ TRUE 4.4.4 Indexing: Accessing Your Data Once you have data stored in these structures, you need to be able to get specific pieces out. This is called indexing or subsetting. Position-based indexing (using square brackets []): # indexing - vectors numbers_vector &lt;- c(10, 20, 30, 40, 50) numbers_vector[1] # First element: 10 ## [1] 10 numbers_vector[3] # Third element: 30 ## [1] 30 numbers_vector[c(1, 3)] # First and third elements: 10, 30 ## [1] 10 30 # indexing - lists mixed_list &lt;- list(1, &quot;2&quot;, 6.7) mixed_list[1] # Returns a list containing just the name ## [[1]] ## [1] 1 mixed_list[2] ## [[1]] ## [1] &quot;2&quot; # indexing - data frame students &lt;- data.frame( name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;), age = c(20, 21, 19), grade = c(&quot;A&quot;, &quot;B&quot;, &quot;A+&quot;) ) # Matrix-style indexing [row, column] students[1, 2] # First row, second column: 20 ## [1] 20 students[1, ] # Entire first row ## name age grade ## 1 Alice 20 A students[, 2] # Entire second column (ages) ## [1] 20 21 19 students[1:2, c(&quot;name&quot;, &quot;age&quot;)] # First two rows, name and age columns ## name age ## 1 Alice 20 ## 2 Bob 21 # List-style indexing (by column) students$name # The name column ## [1] &quot;Alice&quot; &quot;Bob&quot; &quot;Charlie&quot; students[[&quot;age&quot;]] # The age column ## [1] 20 21 19 students[&quot;grade&quot;] # The grade column (returns data frame) ## grade ## 1 A ## 2 B ## 3 A+ # Logical indexing students[students$age &gt; 20, ] # All rows where age &gt; 20 ## name age grade ## 2 Bob 21 B students[students$grade == &quot;A&quot;, ] # All rows where grade is &quot;A&quot; ## name age grade ## 1 Alice 20 A Understanding these data structures and how to index them is crucial because almost everything you do in R involves manipulating data stored in these formats. Whether you’re reading a CSV file (which becomes a data frame), performing calculations (often on vectors), or organizing complex results (in lists), these concepts form the foundation of effective R programming. 4.5 Conditions and Comparisons One thing we often need to do with our datatypes, are comparisons. This is basically checking whether a statement is TRUE or FALSE. Here are the basic comparison operators in R: Operator Meaning Example Result   == Equal to 3 == 3 TRUE != Not equal to 3 != 5 TRUE &gt; Greater than 4 &gt; 2 TRUE &lt; Less than 4 &lt; 2 FALSE &gt;= Greater than or equal to 4 &gt;= 4 TRUE &lt;= Less than or equal to 4 &lt;= 3 FALSE %in% Element inside an object 1 %in% c(1,2) TRUE And for combining logical statements, we use operators, of which these are available: Operator Meaning Example Result &amp; AND TRUE &amp; FALSE FALSE | OR TRUE | FALSE TRUE ! NOT !FALSE TRUE 4.6 Conditional execution with Sometimes we only want to execute a piece of code under a certain condition. For that, we have what is called an if-statement. In R we write if (...comparison...){code to be executed}. The basic if statement: x &lt;- 4 if (x &gt; 0) { print(&quot;x is positive&quot;) } ## [1] &quot;x is positive&quot; Besides the if part, we can also add an else part, which will be executed if the comparison is FALSE. if ... else x &lt;- -1 if (x &gt; 0) { print(&quot;x is positive&quot;) } else { print(&quot;x is not positive&quot;) } ## [1] &quot;x is not positive&quot; 4.7 Repeating lines of code Sometimes, we want to execute a piece of code a certain number of times, or we want to execute the same code based on a bunch of different variables. We can repeat code using a for - loop. Basically, we write for (iteration) {code to be executed}. For example, let’s print the numbers 1 to 5. For that to be done, first we write a vector from 1 to 5, which we do through 1:5. Then we iterate through all the elements in that vector by: for (i in 1:5) { # for i = 1 until i = 5 print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 That was a classical example where we iterate through a bunch of integers. We can also iterate through other things: names = c(&#39;Marie Curie&#39;, &#39;Jenniffer Doudna&#39;, &#39;Alexander Flemming&#39;) for (name in names) { print(paste(name, &quot;won the Nobel Prize&quot;)) } ## [1] &quot;Marie Curie won the Nobel Prize&quot; ## [1] &quot;Jenniffer Doudna won the Nobel Prize&quot; ## [1] &quot;Alexander Flemming won the Nobel Prize&quot; 4.8 Functions People write code into functions in R. These are sometimes added into packages and published, so that anyone using R can use them. Examples of functions are paste(), log() (taking the logarithm base 10 of a number) and many others. When we make our own code, we sometimes end up writing huge chunks that we want to repeat, but can’t really put in a for loop. For that we can write our own functions! Here I’ll show an example testing whether or not our variable is negative or positive: positive_check &lt;- function(x) { # the name of the function is positive_or_negative, with the parameter &#39;x&#39; if (x &lt; 0) { # if x is smaller than 0 return(FALSE) # the output of the function is FALSE } else { # otherwise (if x is larger than, or equal to, 0) return(TRUE) # return TRUE } } And now that we’ve defined this function we can easily use it by positive_check(1), for example: positive_check(1) ## [1] TRUE positive_check(Inf) ## [1] TRUE "],["introduction-to-the-tidyverse.html", "Chapter 5 Introduction to the Tidyverse 5.1 Data Structure: Wide vs. Tidy Data 5.2 Core dplyr Functions for Data Manipulation 5.3 Additional Essential Functions 5.4 Practical Example: Data Analysis Workflow 5.5 Function Summary Table 5.6 Conclusion", " Chapter 5 Introduction to the Tidyverse The tidyverse is a collection of R packages designed for data science that share an underlying design philosophy, grammar, and data structures. These packages are essential tools for anyone working with data in R, providing intuitive and consistent functions for data cleaning, manipulation, and visualization. The tidyverse follows Hadley Wickham’s philosophy of tidy data, where: Each variable is a column Each observation is a row Each value is a cell This structure makes data analysis more intuitive and efficient. library(tidyverse) # Loads core tidyverse packages ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.4 ✔ readr 2.1.5 ## ✔ forcats 1.0.0 ✔ stringr 1.5.1 ## ✔ ggplot2 3.5.1 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.3 ✔ tidyr 1.3.1 ## ✔ purrr 1.0.2 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors library(gapminder) # Example dataset 5.1 Data Structure: Wide vs. Tidy Data 5.1.1 Understanding the Difference Let’s explore the concept of tidy data with a practical example: # Create a wide-format dataset flu_cases &lt;- data.frame( year = c(2020, 2021), male_cases = c(120, 150), female_cases = c(100, 130) ) print(&quot;Wide format (not tidy):&quot;) ## [1] &quot;Wide format (not tidy):&quot; flu_cases ## year male_cases female_cases ## 1 2020 120 100 ## 2 2021 150 130 Why isn’t this tidy? The variable “sex” is encoded in the column names rather than being a proper column with values. 5.1.2 Reshaping Data with tidyr 5.1.2.1 Making Data Longer with pivot_longer() flu_tidy &lt;- flu_cases %&gt;% pivot_longer( cols = c(male_cases, female_cases), # Columns to pivot names_to = &quot;sex&quot;, # New column for variable names values_to = &quot;cases&quot; # New column for values ) %&gt;% mutate(sex = str_replace(sex, &quot;_cases&quot;, &quot;&quot;)) # Clean up the sex values print(&quot;Tidy format (long):&quot;) ## [1] &quot;Tidy format (long):&quot; flu_tidy ## # A tibble: 4 × 3 ## year sex cases ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2020 male 120 ## 2 2020 female 100 ## 3 2021 male 150 ## 4 2021 female 130 5.1.2.2 Making Data Wider with pivot_wider() flu_wide_again &lt;- flu_tidy %&gt;% pivot_wider( names_from = sex, # Column to get new column names from values_from = cases, # Column to get values from names_glue = &quot;{sex}_cases&quot; # Template for new column names ) print(&quot;Back to wide format:&quot;) ## [1] &quot;Back to wide format:&quot; flu_wide_again ## # A tibble: 2 × 3 ## year male_cases female_cases ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2020 120 100 ## 2 2021 150 130 5.2 Core dplyr Functions for Data Manipulation Let’s explore the essential dplyr functions using the gapminder dataset: head(gapminder, 10) ## # A tibble: 10 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. ## 7 Afghanistan Asia 1982 39.9 12881816 978. ## 8 Afghanistan Asia 1987 40.8 13867957 852. ## 9 Afghanistan Asia 1992 41.7 16317921 649. ## 10 Afghanistan Asia 1997 41.8 22227415 635. 5.2.1 The Pipe Operator (%&gt;%) The pipe operator is the backbone of tidyverse workflows. It passes the result of one function as the first argument to the next function: # Instead of: function_c(function_b(function_a(data), arg1), arg2) # We write: data %&gt;% function_a() %&gt;% function_b(arg1) %&gt;% function_c(arg2) 5.2.2 select(): Choose Columns # Select specific columns selected_columns &lt;- gapminder %&gt;% select(country, year, lifeExp, pop) head(selected_columns) ## # A tibble: 6 × 4 ## country year lifeExp pop ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Afghanistan 1952 28.8 8425333 ## 2 Afghanistan 1957 30.3 9240934 ## 3 Afghanistan 1962 32.0 10267083 ## 4 Afghanistan 1967 34.0 11537966 ## 5 Afghanistan 1972 36.1 13079460 ## 6 Afghanistan 1977 38.4 14880372 # Select columns by pattern gapminder %&gt;% select(country, starts_with(&quot;life&quot;)) %&gt;% head() ## # A tibble: 6 × 2 ## country lifeExp ## &lt;fct&gt; &lt;dbl&gt; ## 1 Afghanistan 28.8 ## 2 Afghanistan 30.3 ## 3 Afghanistan 32.0 ## 4 Afghanistan 34.0 ## 5 Afghanistan 36.1 ## 6 Afghanistan 38.4 # Select everything except certain columns gapminder %&gt;% select(-continent, -gdpPercap) %&gt;% head() ## # A tibble: 6 × 4 ## country year lifeExp pop ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Afghanistan 1952 28.8 8425333 ## 2 Afghanistan 1957 30.3 9240934 ## 3 Afghanistan 1962 32.0 10267083 ## 4 Afghanistan 1967 34.0 11537966 ## 5 Afghanistan 1972 36.1 13079460 ## 6 Afghanistan 1977 38.4 14880372 5.2.3 filter(): Choose Rows # Filter by exact match gapminder %&gt;% filter(year == 2007) %&gt;% head() ## # A tibble: 6 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 2007 43.8 31889923 975. ## 2 Albania Europe 2007 76.4 3600523 5937. ## 3 Algeria Africa 2007 72.3 33333216 6223. ## 4 Angola Africa 2007 42.7 12420476 4797. ## 5 Argentina Americas 2007 75.3 40301927 12779. ## 6 Australia Oceania 2007 81.2 20434176 34435. # Filter by multiple conditions gapminder %&gt;% filter(year == 2007, continent == &quot;Europe&quot;) %&gt;% head() ## # A tibble: 6 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Albania Europe 2007 76.4 3600523 5937. ## 2 Austria Europe 2007 79.8 8199783 36126. ## 3 Belgium Europe 2007 79.4 10392226 33693. ## 4 Bosnia and Herzegovina Europe 2007 74.9 4552198 7446. ## 5 Bulgaria Europe 2007 73.0 7322858 10681. ## 6 Croatia Europe 2007 75.7 4493312 14619. # Filter using %in% operator gapminder %&gt;% filter(continent %in% c(&#39;Oceania&#39;, &#39;Africa&#39;)) %&gt;% head() ## # A tibble: 6 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Algeria Africa 1952 43.1 9279525 2449. ## 2 Algeria Africa 1957 45.7 10270856 3014. ## 3 Algeria Africa 1962 48.3 11000948 2551. ## 4 Algeria Africa 1967 51.4 12760499 3247. ## 5 Algeria Africa 1972 54.5 14760787 4183. ## 6 Algeria Africa 1977 58.0 17152804 4910. # Filter by numeric conditions gapminder %&gt;% filter(pop &gt; 100000000, lifeExp &gt; 70) %&gt;% head() ## # A tibble: 6 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Brazil Americas 2002 71.0 179914212 8131. ## 2 Brazil Americas 2007 72.4 190010647 9066. ## 3 China Asia 1997 70.4 1230075000 2289. ## 4 China Asia 2002 72.0 1280400000 3119. ## 5 China Asia 2007 73.0 1318683096 4959. ## 6 Indonesia Asia 2007 70.6 223547000 3541. 5.2.4 mutate(): Create or Modify Columns # Create new columns gapminder_enhanced &lt;- gapminder %&gt;% mutate( pop_millions = pop / 1000000, gdp_total = pop * gdpPercap, pop_log = log10(pop) ) head(gapminder_enhanced) ## # A tibble: 6 × 9 ## country continent year lifeExp pop gdpPercap pop_millions gdp_total ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. 8.43 6.57e 9 ## 2 Afghanistan Asia 1957 30.3 9240934 821. 9.24 7.59e 9 ## 3 Afghanistan Asia 1962 32.0 10267083 853. 10.3 8.76e 9 ## 4 Afghanistan Asia 1967 34.0 11537966 836. 11.5 9.65e 9 ## 5 Afghanistan Asia 1972 36.1 13079460 740. 13.1 9.68e 9 ## 6 Afghanistan Asia 1977 38.4 14880372 786. 14.9 1.17e10 ## # ℹ 1 more variable: pop_log &lt;dbl&gt; # Conditional mutations with ifelse gapminder %&gt;% mutate( pop_category = ifelse(pop &gt; 50000000, &quot;Large&quot;, &quot;Small&quot;) ) %&gt;% head() ## # A tibble: 6 × 7 ## country continent year lifeExp pop gdpPercap pop_category ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. Small ## 2 Afghanistan Asia 1957 30.3 9240934 821. Small ## 3 Afghanistan Asia 1962 32.0 10267083 853. Small ## 4 Afghanistan Asia 1967 34.0 11537966 836. Small ## 5 Afghanistan Asia 1972 36.1 13079460 740. Small ## 6 Afghanistan Asia 1977 38.4 14880372 786. Small 5.2.5 transmute(): Create New Columns (Drop Others) # Keep only the newly created columns gapminder %&gt;% transmute( country = country, year = year, gdp_total = pop * gdpPercap, pop_millions = pop / 1000000 ) %&gt;% head() ## # A tibble: 6 × 4 ## country year gdp_total pop_millions ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1952 6567086330. 8.43 ## 2 Afghanistan 1957 7585448670. 9.24 ## 3 Afghanistan 1962 8758855797. 10.3 ## 4 Afghanistan 1967 9648014150. 11.5 ## 5 Afghanistan 1972 9678553274. 13.1 ## 6 Afghanistan 1977 11697659231. 14.9 5.2.6 arrange(): Sort Rows # Sort by one column (ascending) gapminder %&gt;% filter(year == 2007) %&gt;% arrange(lifeExp) %&gt;% head() ## # A tibble: 6 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Swaziland Africa 2007 39.6 1133066 4513. ## 2 Mozambique Africa 2007 42.1 19951656 824. ## 3 Zambia Africa 2007 42.4 11746035 1271. ## 4 Sierra Leone Africa 2007 42.6 6144562 863. ## 5 Lesotho Africa 2007 42.6 2012649 1569. ## 6 Angola Africa 2007 42.7 12420476 4797. # Sort by multiple columns (descending) gapminder %&gt;% filter(year == 2007) %&gt;% arrange(desc(gdpPercap), desc(lifeExp)) %&gt;% head() ## # A tibble: 6 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Norway Europe 2007 80.2 4627926 49357. ## 2 Kuwait Asia 2007 77.6 2505559 47307. ## 3 Singapore Asia 2007 80.0 4553009 47143. ## 4 United States Americas 2007 78.2 301139947 42952. ## 5 Ireland Europe 2007 78.9 4109086 40676. ## 6 Hong Kong, China Asia 2007 82.2 6980412 39725. 5.2.7 group_by() and summarise(): Group Operations # Basic grouping and summarizing gapminder %&gt;% filter(year == 2007) %&gt;% group_by(continent) %&gt;% summarise( mean_lifeExp = mean(lifeExp), sd_lifeExp = sd(lifeExp), total_pop = sum(pop), n_countries = n(), .groups = &#39;drop&#39; # Automatically ungroup ) ## # A tibble: 5 × 5 ## continent mean_lifeExp sd_lifeExp total_pop n_countries ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Africa 54.8 9.63 929539692 52 ## 2 Americas 73.6 4.44 898871184 25 ## 3 Asia 70.7 7.96 3811953827 33 ## 4 Europe 77.6 2.98 586098529 30 ## 5 Oceania 80.7 0.729 24549947 2 # Multiple grouping variables gapminder %&gt;% filter(year %in% c(1997, 2007)) %&gt;% group_by(continent, year) %&gt;% summarise( avg_gdp = mean(gdpPercap), countries = n(), .groups = &#39;drop&#39; ) ## # A tibble: 10 × 4 ## continent year avg_gdp countries ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Africa 1997 2379. 52 ## 2 Africa 2007 3089. 52 ## 3 Americas 1997 8889. 25 ## 4 Americas 2007 11003. 25 ## 5 Asia 1997 9834. 33 ## 6 Asia 2007 12473. 33 ## 7 Europe 1997 19077. 30 ## 8 Europe 2007 25054. 30 ## 9 Oceania 1997 24024. 2 ## 10 Oceania 2007 29810. 2 5.3 Additional Essential Functions 5.3.1 rename(): Change Column Names # Rename columns gapminder %&gt;% rename( life_expectancy = lifeExp, gdp_per_capita = gdpPercap, population = pop ) %&gt;% head() ## # A tibble: 6 × 6 ## country continent year life_expectancy population gdp_per_capita ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. # Rename with a function gapminder %&gt;% rename_with(toupper, c(country, continent)) %&gt;% head() ## # A tibble: 6 × 6 ## COUNTRY CONTINENT year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. 5.3.2 Data Type Conversions # Create sample data with mixed types sample_data &lt;- data.frame( id = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;), date_string = c(&quot;2020-01-01&quot;, &quot;2020-02-01&quot;, &quot;2020-03-01&quot;), value = c(&quot;10.5&quot;, &quot;20.3&quot;, &quot;15.7&quot;), stringsAsFactors = FALSE ) # Convert data types sample_data_converted &lt;- sample_data %&gt;% mutate( id = as.numeric(id), date_string = as.Date(date_string), value = as.numeric(value), id_char = as.character(id) ) str(sample_data_converted) ## &#39;data.frame&#39;: 3 obs. of 4 variables: ## $ id : num 1 2 3 ## $ date_string: Date, format: &quot;2020-01-01&quot; &quot;2020-02-01&quot; ... ## $ value : num 10.5 20.3 15.7 ## $ id_char : chr &quot;1&quot; &quot;2&quot; &quot;3&quot; 5.3.3 across(): Apply Functions to Multiple Columns # Apply function to multiple columns gapminder %&gt;% group_by(continent) %&gt;% summarise( across(c(lifeExp, pop, gdpPercap), mean), .groups = &#39;drop&#39; ) ## # A tibble: 5 × 4 ## continent lifeExp pop gdpPercap ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Africa 48.9 9916003. 2194. ## 2 Americas 64.7 24504795. 7136. ## 3 Asia 60.1 77038722. 7902. ## 4 Europe 71.9 17169765. 14469. ## 5 Oceania 74.3 8874672. 18622. # Apply multiple functions gapminder %&gt;% filter(year == 2007) %&gt;% group_by(continent) %&gt;% summarise( across(c(lifeExp, gdpPercap), list(mean = mean, sd = sd, min = min, max = max)), .groups = &#39;drop&#39; ) ## # A tibble: 5 × 9 ## continent lifeExp_mean lifeExp_sd lifeExp_min lifeExp_max gdpPercap_mean ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Africa 54.8 9.63 39.6 76.4 3089. ## 2 Americas 73.6 4.44 60.9 80.7 11003. ## 3 Asia 70.7 7.96 43.8 82.6 12473. ## 4 Europe 77.6 2.98 71.8 81.8 25054. ## 5 Oceania 80.7 0.729 80.2 81.2 29810. ## # ℹ 3 more variables: gdpPercap_sd &lt;dbl&gt;, gdpPercap_min &lt;dbl&gt;, ## # gdpPercap_max &lt;dbl&gt; 5.3.4 recode(): Recode Values # Recode values gapminder %&gt;% mutate( continent_short = recode(continent, &quot;Africa&quot; = &quot;AF&quot;, &quot;Americas&quot; = &quot;AM&quot;, &quot;Asia&quot; = &quot;AS&quot;, &quot;Europe&quot; = &quot;EU&quot;, &quot;Oceania&quot; = &quot;OC&quot; ) ) %&gt;% select(country, continent, continent_short) %&gt;% head() ## # A tibble: 6 × 3 ## country continent continent_short ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 Afghanistan Asia AS ## 2 Afghanistan Asia AS ## 3 Afghanistan Asia AS ## 4 Afghanistan Asia AS ## 5 Afghanistan Asia AS ## 6 Afghanistan Asia AS 5.3.5 case_when(): Multiple Conditional Logic # Multiple conditions with case_when gapminder %&gt;% mutate( development_level = case_when( gdpPercap &lt; 1000 ~ &quot;Low income&quot;, gdpPercap &lt; 5000 ~ &quot;Lower middle income&quot;, gdpPercap &lt; 15000 ~ &quot;Upper middle income&quot;, gdpPercap &gt;= 15000 ~ &quot;High income&quot;, TRUE ~ &quot;Unknown&quot; # Default case ), pop_size = case_when( pop &lt; 10000000 ~ &quot;Small&quot;, pop &lt; 50000000 ~ &quot;Medium&quot;, pop &gt;= 50000000 ~ &quot;Large&quot; ) ) %&gt;% select(country, year, gdpPercap, development_level, pop, pop_size) %&gt;% filter(year == 2007) %&gt;% head(10) ## # A tibble: 10 × 6 ## country year gdpPercap development_level pop pop_size ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 2007 975. Low income 31889923 Medium ## 2 Albania 2007 5937. Upper middle income 3600523 Small ## 3 Algeria 2007 6223. Upper middle income 33333216 Medium ## 4 Angola 2007 4797. Lower middle income 12420476 Medium ## 5 Argentina 2007 12779. Upper middle income 40301927 Medium ## 6 Australia 2007 34435. High income 20434176 Medium ## 7 Austria 2007 36126. High income 8199783 Small ## 8 Bahrain 2007 29796. High income 708573 Small ## 9 Bangladesh 2007 1391. Lower middle income 150448339 Large ## 10 Belgium 2007 33693. High income 10392226 Medium 5.3.6 replace_na(): Handle Missing Values # Create data with missing values data_with_na &lt;- data.frame( name = c(&quot;Alice&quot;, &quot;Bob&quot;, NA, &quot;David&quot;), age = c(25, NA, 35, 40), city = c(&quot;New York&quot;, &quot;Boston&quot;, &quot;Chicago&quot;, NA) ) print(&quot;Original data:&quot;) ## [1] &quot;Original data:&quot; data_with_na ## name age city ## 1 Alice 25 New York ## 2 Bob NA Boston ## 3 &lt;NA&gt; 35 Chicago ## 4 David 40 &lt;NA&gt; # Replace NA values data_cleaned &lt;- data_with_na %&gt;% mutate( name = replace_na(name, &quot;Unknown&quot;), age = replace_na(age, median(age, na.rm = TRUE)), city = replace_na(city, &quot;Not specified&quot;) ) print(&quot;After replacing NA values:&quot;) ## [1] &quot;After replacing NA values:&quot; data_cleaned ## name age city ## 1 Alice 25 New York ## 2 Bob 35 Boston ## 3 Unknown 35 Chicago ## 4 David 40 Not specified 5.3.7 which(): Find Positions # Using which to find positions sample_vector &lt;- c(10, 25, 30, 15, 40, 35) # Find positions where condition is TRUE positions &lt;- which(sample_vector &gt; 20) print(paste(&quot;Positions where value &gt; 20:&quot;, paste(positions, collapse = &quot;, &quot;))) ## [1] &quot;Positions where value &gt; 20: 2, 3, 5, 6&quot; # Use in data frame context gapminder %&gt;% filter(year == 2007) %&gt;% mutate(rank_gdp = rank(desc(gdpPercap))) %&gt;% filter(rank_gdp &lt;= 5) %&gt;% select(country, gdpPercap, rank_gdp) %&gt;% arrange(rank_gdp) ## # A tibble: 5 × 3 ## country gdpPercap rank_gdp ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Norway 49357. 1 ## 2 Kuwait 47307. 2 ## 3 Singapore 47143. 3 ## 4 United States 42952. 4 ## 5 Ireland 40676. 5 5.4 Practical Example: Data Analysis Workflow Let’s combine multiple functions in a realistic analysis: # Comprehensive analysis: Life expectancy trends by continent life_exp_analysis &lt;- gapminder %&gt;% # Filter for recent decades filter(year &gt;= 1990) %&gt;% # Create additional variables mutate( decade = case_when( year %in% 1990:1999 ~ &quot;1990s&quot;, year %in% 2000:2007 ~ &quot;2000s&quot; ), gdp_category = case_when( gdpPercap &lt; 2000 ~ &quot;Low GDP&quot;, gdpPercap &lt; 10000 ~ &quot;Medium GDP&quot;, gdpPercap &gt;= 10000 ~ &quot;High GDP&quot; ) ) %&gt;% # Group and summarize group_by(continent, decade, gdp_category) %&gt;% summarise( avg_life_exp = mean(lifeExp), countries = n(), total_pop = sum(pop), .groups = &#39;drop&#39; ) %&gt;% # Filter out small groups filter(countries &gt;= 3) %&gt;% # Arrange results arrange(continent, decade, desc(avg_life_exp)) print(&quot;Life expectancy analysis by continent, decade, and GDP category:&quot;) ## [1] &quot;Life expectancy analysis by continent, decade, and GDP category:&quot; life_exp_analysis ## # A tibble: 21 × 6 ## continent decade gdp_category avg_life_exp countries total_pop ## &lt;fct&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Africa 1990s Medium GDP 61.9 28 381335877 ## 2 Africa 1990s Low GDP 50.3 74 1019466696 ## 3 Africa 2000s Medium GDP 59.7 27 632430409 ## 4 Africa 2000s High GDP 58.5 7 13862646 ## 5 Africa 2000s Low GDP 51.5 70 1116970553 ## 6 Americas 1990s High GDP 75.1 10 689423253 ## 7 Americas 1990s Medium GDP 69.9 38 833511034 ## 8 Americas 2000s High GDP 76.3 15 976865109 ## 9 Americas 2000s Medium GDP 72.3 33 755668372 ## 10 Asia 1990s High GDP 75.0 21 479574324 ## # ℹ 11 more rows 5.5 Function Summary Table Here’s a comprehensive summary of all the tidyverse functions covered: Function Description Example select() Choose specific columns from a dataset select(country, year, pop) filter() Choose specific rows based on conditions filter(year == 2007, pop &gt; 1000000) mutate() Create new columns or modify existing ones mutate(gdp_total = pop * gdpPercap) transmute() Create new columns and drop all others transmute(country, gdp_billions = gdp/1e9) arrange() Sort rows by one or more columns arrange(desc(lifeExp)) group_by() Group rows for grouped operations group_by(continent, year) summarise() Calculate summary statistics for groups summarise(mean_life = mean(lifeExp)) rename() Change column names rename(life_expectancy = lifeExp) pivot_longer() Convert wide data to long format (tidy) pivot_longer(cols = c(col1, col2)) pivot_wider() Convert long data to wide format pivot_wider(names_from = key) across() Apply functions to multiple columns at once across(c(col1, col2), mean) recode() Recode values in a column recode(continent, 'Asia' = 'AS') case_when() Handle multiple conditional logic case_when(pop &lt; 1e6 ~ 'Small') replace_na() Replace missing (NA) values replace_na(column, 'Unknown') as.numeric() Convert to numeric data type as.numeric(character_column) as.character() Convert to character data type as.character(numeric_column) which() Find positions where condition is TRUE which(vector &gt; threshold) 5.6 Conclusion The tidyverse provides a consistent and intuitive grammar for data manipulation in R. By mastering these core functions, you’ll be able to efficiently clean, transform, and analyze data. The key principles to remember are: Start with tidy data - each variable in a column, each observation in a row Use the pipe operator (%&gt;%) to chain operations together Combine functions to create powerful data manipulation workflows Group operations allow for sophisticated analyses across different categories "],["working-with-epidemiological-data.html", "Chapter 6 Working with epidemiological data 6.1 Acessing data 6.2 Case Study 1: Yellow Fever", " Chapter 6 Working with epidemiological data Data is at the heart of epidemiology. We look at where and when diseases occur, to hopefully better understand their origin or their cause, how to prevent or cure the disease, or to make predictions about the future. That’s why epidemiologists need to be able to work with disease data, and know how and where to look for it! That’s why in this chapter we go over some data-extraction, processing, visualization and analysis. We start simple, with an example of Yellow Fever, and then get into more complex case in which we try to understand cholera outbreaks. 6.1 Acessing data raw data cleaned data harmonization -&gt; standardization data cleaning: fixing or removing incorrect, incosistent or missing data data harmonziation: standardization or alignment of data ## (Imperfect) epidemiological data 6.2 Case Study 1: Yellow Fever Yellow fever (YF) is a severe and sometimes fatal hemorrhagic fever caused by a flavivirus with a single-stranded, negatively oriented RNA genome. It primarily affects regions in Africa and Latin America, where the virus sustains itself through a sylvatic cycle involving wild mosquitoes and non-human primates. In Brazil, for instance, mosquito species like Haemagogus and Sabethes maintain this cycle in forested areas. While a highly effective vaccine exists, yellow fever outbreaks still occur, particularly when the virus spills over into urban settings (Chippaux &amp; Chippaux, 2018). Historically, yellow fever was confined to Africa until the transatlantic slave trade introduced it to Latin America, where favorable climates and mosquito vectors allowed it to take root. Cities like New Orleans suffered repeated, devastating outbreaks in the past. Brazil saw a decline in cases mid-20th century, but a resurgence occurred between 2016 and 2018, with over 2,000 reported cases and a strikingly high death toll of 681. This resurgence was partly driven by the spread of the virus into urban areas, facilitated by Aedes aegypti and Aedes albopictus, mosquitoes that thrive in cities. Curiously, yellow fever has never established itself in Asia despite the presence of competent vectors and similar arboviruses, a mystery that may relate to immunological cross-reactivity with other flaviviruses like dengue (Chippaux &amp; Chippaux, 2018). The WHO has data data available for download for many different things, including casenumbers for many infectious diseases, including that for YF. The raw data for YF you can find here. I have cleaned this data a little so that the dataframe is as concise as possible, and so that all the countrynames correctly map to the ones in the world_shapefile dataset. 6.2.0.1 Installing packages library(scales) library(ggplot2) library(readr) ## ## Attaching package: &#39;readr&#39; ## The following object is masked from &#39;package:scales&#39;: ## ## col_factor library(glue) # The following packages print a lot of noise when installing so I silence their output # by wrapping them in a `suppressPackageStartupMessages({}) suppressPackageStartupMessages({ library(tidyverse) library(gapminder) library(rnaturalearth) library(rnaturalearthdata) library(sf) }) 6.2.0.2 Installing world shapedata Eventually, I want to show you how to make some plots and some maps. For that, we need to load the shape of the world, so that we can fill in countries with certain colors and such. For that we’ll load the world shapefile from the package rnaturalearth. This dataset includes many different columns, but we only require some of them; name, geometry and continent. world_shapefile = ne_countries(scale = &quot;medium&quot;, returnclass = &quot;sf&quot;) %&gt;% select(c(&quot;name&quot;,&quot;geometry&quot;, &quot;continent&quot;)) colnames(world_shapefile)[1] = c(&quot;country&quot;) continents_list = unique(world_shapefile$continent) countries_continents &lt;- world_shapefile %&gt;% st_set_geometry(NULL) %&gt;% select(country, continent) # World map ggplot(world_shapefile) + geom_sf(aes(fill = continent), color = &quot;black&quot;, linewidth = 0.01) + theme_minimal(base_size = 14) + labs( title = &#39;world shapefile&#39;, ) + theme( panel.background = element_rect(fill = &quot;#f7f9fc&quot;), legend.position = &quot;right&quot;, plot.title = element_text(face = &quot;bold&quot;, size = 16), plot.subtitle = element_text(size = 12) ) 6.2.0.3 Yellow Fever data who_yellowfever = read_csv(&quot;data/cleaned_yellowfever.csv&quot;, show_col_types = FALSE) # head allows us to preview the table head(who_yellowfever) ## # A tibble: 6 × 3 ## country year cases ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Algeria 2024 0 ## 2 Andorra 2024 0 ## 3 Anguilla 2024 0 ## 4 Antigua and Barb. 2024 0 ## 5 Armenia 2024 0 ## 6 Aruba 2024 0 # draw up some specifications of the dataset n_countries = length(unique(who_yellowfever$country)) first_year = min(who_yellowfever$year) last_year = max(who_yellowfever$year) glue(&quot;\\nThe dataframe contains yearly casedata for {n_countries} countries between {first_year} and {last_year}&quot;) ## The dataframe contains yearly casedata for 212 countries between 1974 and 2024 6.2.0.4 Global yearly cases Let’s first get a global overview of YF in the world the past 50 years. To start with, we will create a graph showing the number of cases in the world per year, and then we’ll show it per continent to see which are the ones most affected. # Global epicurve global_yearly_casenumbers &lt;- who_yellowfever %&gt;% group_by(year) %&gt;% summarise(cases = sum(cases)) ggplot(global_yearly_casenumbers) + geom_line(aes(x = year, y = cases), color = &#39;black&#39;, linewidth = 1.5) + # black outline geom_line(aes(x = year, y = cases), color = &#39;#ffcc00&#39;, linewidth = 1) + # yellow line scale_x_continuous(breaks = pretty_breaks(n = 20)) + # I don&#39;t want a break per year. I do a max of 20 year theme_classic(base_size = 14) + labs( x = &quot;&quot;, title = &quot;Yellow Fever Cases in the world 1974 - 2024&quot;, subtitle = &quot;number of cases reported to the WHO&quot; ) 6.2.0.5 Yearly cases per continent yearly_casenumbers_continent = merge(who_yellowfever, countries_continents, by = &quot;country&quot;) %&gt;% group_by(year, continent) %&gt;% summarise(cases = sum(cases), .groups = &quot;drop&quot;) %&gt;% filter(continent %in% continents_list) ggplot(yearly_casenumbers_continent) + geom_line(aes(x = year, y = cases, color = continent), linewidth = 1.5) + scale_x_continuous(breaks = pretty_breaks(n = 20)) + theme_classic(base_size = 14) + scale_color_brewer(palette = &quot;Dark2&quot;) + # 7 distinct colors labs( x = &quot;&quot;, title = &quot;Yellow Fever Cases in the world 1973 - 2024 per continent&quot;, subtitle = &quot;number of cases reported to the WHO&quot; ) + theme(legend.position = &quot;bottom&quot;) We can clearly tell that since 1974, Africa has experienced the largest burden by YF, though South America suffered between 2016 and 2019 as well. Let’s have a look at the total sum of cases per country in the past, to see which countries and which areas are affected the most. 6.2.0.6 Historical burden cases_per_country = who_yellowfever%&gt;% group_by(country) %&gt;% summarise(cases = sum(cases)) mapdata = st_as_sf(merge(cases_per_country, world_shapefile, on = &#39;country&#39;, all.y = TRUE)) mapdata$cases_category &lt;- cut( mapdata$cases, breaks = c(0,100, 500, 1000, 2000, 5000, 10000, 20000, Inf), # 8 breaks → 7 intervals labels = c(&quot;0 - 100&quot;, &quot;101-500&quot;,&quot;501-1000&quot;, &quot;1001-2000&quot;, &quot;2001-5000&quot;, &quot;5001-10000&quot;, &quot;10001-20000&quot;, &quot;&gt;20000&quot;), include.lowest = TRUE ) pl &lt;- ggplot(mapdata) + geom_sf(aes(fill = cases_category), color = &quot;black&quot;, size = 0.1) + scale_fill_brewer(palette = &quot;YlOrRd&quot;, na.value = &quot;gray95&quot;, name = &quot;Cases&quot;) + theme_minimal(base_size = 14) + theme( panel.background = element_rect(fill = &quot;#E0FFFF&quot;), # clean light background legend.position = &quot;right&quot;, plot.title = element_text(face = &quot;bold&quot;, size = 16), plot.subtitle = element_text(size = 12) ) + labs(title = &#39;Cumulative cases 1974 - 2024&#39;) pl From this we can clearly see that the most affected regions are central and west Africa, as well as central(?) Latin America. This does not allow us to look into temporal dynamics though, so let’s look a bit further into that using a function. 6.2.0.7 Country-specific epicurves plot_country = function(country_filter){ filtered_df &lt;- who_yellowfever %&gt;% filter(country == country_filter) pl = ggplot(filtered_df) + geom_line(aes(x = year, y = cases), color = &#39;black&#39;, linewidth = 1.5) + # black outline geom_line(aes(x = year, y = cases), color = &#39;#ffcc00&#39;, linewidth = 1) + # yellow line geom_point(aes(x = year, y = cases), color = &#39;black&#39;, linewidth = 1) + # black outline scale_x_continuous(breaks = pretty_breaks(n = 20)) + theme_classic(base_size = 14) + labs(x = &quot;&quot;, y=&#39;cases&#39;) + labs( title = paste0(&quot;Yellow Fever Cases in &quot;, country_filter, &quot; 1973 - 2024&quot;), subtitle = &quot;number of cases reported to the WHO&quot; ) return(pl) } plot_country(&quot;Dem. Rep. Congo&quot;) ## Warning in geom_point(aes(x = year, y = cases), color = &quot;black&quot;, linewidth = ## 1): Ignoring unknown parameters: `linewidth` plot_country(&quot;Chad&quot;) ## Warning in geom_point(aes(x = year, y = cases), color = &quot;black&quot;, linewidth = ## 1): Ignoring unknown parameters: `linewidth` plot_country(&quot;Nigeria&quot;) ## Warning in geom_point(aes(x = year, y = cases), color = &quot;black&quot;, linewidth = ## 1): Ignoring unknown parameters: `linewidth` plot_country(&quot;Ghana&quot;) ## Warning in geom_point(aes(x = year, y = cases), color = &quot;black&quot;, linewidth = ## 1): Ignoring unknown parameters: `linewidth` plot_country(&quot;Brazil&quot;) ## Warning in geom_point(aes(x = year, y = cases), color = &quot;black&quot;, linewidth = ## 1): Ignoring unknown parameters: `linewidth` plot_country(&quot;Peru&quot;) ## Warning in geom_point(aes(x = year, y = cases), color = &quot;black&quot;, linewidth = ## 1): Ignoring unknown parameters: `linewidth` This is actually already interesting! We can see that some many of these countries have very big outbreaks in a specific year, or over a couple of years, while a peak in one country doesn’t necessarily translate in one elsewhere. Peru, for example, had a big outbreak in 1995, and hasn’t had many cases since. Brazil, however, did not report manby cases until 2017 when it detected a huge outbreak that lasted until 2018. "],["modelling.html", "Chapter 7 Modelling 7.1 Compartmental models 7.2 Time series - Forecasting 7.3 Using and applying models", " Chapter 7 Modelling 7.1 Compartmental models 7.1.1 SIR model in theory Compartmental models divide a population into distinct groups, or compartments, each governed by specific rules that describe how individuals move between compartments over time. In epidemiology, one of the most common models is the SIR model, which divides the population into three compartments: Susceptible (S): individuals who can contract the disease Infectious (I): individuals who are currently infected and can transmit the disease Recovered (R): individuals who have recovered and are no longer infectious Individuals move from S to I (when infected), and from I to R (when they recover). This progression can be described using either discrete-time or continuous-time equations. 7.1.1.1 Discrete-Time Formulation The discrete-time version of the SIR model is expressed as: \\[ \\begin{aligned} S_{t+1} &amp;= S_t - \\beta S_t I_t \\\\ I_{t+1} &amp;= I_t + \\beta S_t I_t - \\gamma I_t \\\\ R_{t+1} &amp;= R_t + \\gamma I_t \\end{aligned} \\] Here, \\(S_{t+1}\\) is the number of susceptible individuals at the next time step, determined by subtracting those who become infected. \\(I_{t+1}\\) increases with new infections and decreases as people recover. \\(R_{t+1}\\) increases with recoveries. 7.1.1.2 Continuous-Time Formulation (ODEs) For more refined, continuous-time modeling, we use ordinary differential equations: \\[ \\begin{aligned} \\frac{dS}{dt} &amp;= -\\beta S I \\\\ \\frac{dI}{dt} &amp;= \\beta S I - \\gamma I \\\\ \\frac{dR}{dt} &amp;= \\gamma I \\end{aligned} \\] These represent the rate of change of each compartment over time. Where: - \\(\\beta\\) is the transmission rate - \\(\\gamma\\) is the recovery rate - \\(N = S + I + R\\) is the total population 7.1.2 SIR model in R Despite its simplicity, the SIR model can be surprisingly effective. During the COVID-19 pandemic, many government advisors based their projections on variations of this basic framework. As an example, consider an influenza outbreak that occurred in 1978 at a boarding school in England. The on-site physician documented how many students were sick (in bed) and how many were recovering (convalescent) each day. This dataset is included in the outbreaks R package, allowing us to study it directly. library(outbreaks) data(&quot;influenza_england_1978_school&quot;) outbreak_data &lt;- influenza_england_1978_school head(outbreak_data) ## date in_bed convalescent ## 1 1978-01-22 3 0 ## 2 1978-01-23 8 0 ## 3 1978-01-24 26 0 ## 4 1978-01-25 76 0 ## 5 1978-01-26 225 9 ## 6 1978-01-27 298 17 outbreak_data_long &lt;- pivot_longer(outbreak_data, cols = c(in_bed, convalescent), names_to = &quot;group&quot;, values_to = &quot;count&quot;) ggplot(outbreak_data_long, aes(x = date, y = count, color = group)) + geom_line(linewidth = 1.2) + geom_point(color = &quot;black&quot;, size = 2) + scale_x_date(breaks = outbreak_data_long$date, date_labels = &quot;%b %d&quot;) + labs(title = &quot;Influenza Outbreak (1978 Boarding School)&quot;, x = &quot;&quot;, y = &quot;Number of Students&quot;, color = &quot;Status&quot;) + theme_minimal() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) Now let’s implement the SIR model in R: sir_model &lt;- function(number_of_days, BETA, GAMMA, dt = 1) { N &lt;- 763 I0 &lt;- 1 S0 &lt;- N - I0 R0 &lt;- 0 times &lt;- seq(0, number_of_days, by = dt) n_steps &lt;- length(times) sirdata &lt;- data.frame( t = times, S = numeric(n_steps), I = numeric(n_steps), R = numeric(n_steps) ) sirdata[1, ] &lt;- c(0, S0, I0, R0) for (tt in 2:n_steps) { S_prev &lt;- sirdata$S[tt - 1] I_prev &lt;- sirdata$I[tt - 1] R_prev &lt;- sirdata$R[tt - 1] new_infections &lt;- BETA * S_prev * I_prev * dt new_recoveries &lt;- GAMMA * I_prev * dt new_infections &lt;- min(new_infections, S_prev) new_recoveries &lt;- min(new_recoveries, I_prev) S_new &lt;- S_prev - new_infections I_new &lt;- I_prev + new_infections - new_recoveries R_new &lt;- R_prev + new_recoveries sirdata[tt, ] &lt;- c(times[tt], S_new, I_new, R_new) } return(sirdata) } output = sir_model(14, 0.0026, 0.565, 0.1) sirdata_long = pivot_longer(output, cols = c(&quot;S&quot;, &quot;I&quot;, &quot;R&quot;), names_to = &quot;compartment&quot;, values_to = &quot;count&quot;) ggplot(sirdata_long, aes(x = t, y = count, color = compartment)) + geom_line(linewidth = 1.2) + labs(title = &quot;Influenza Outbreak (1978 Boarding School)&quot;, x = &quot;&quot;, y = &quot;Number of Students&quot;, color = &quot;Status&quot;) + theme_minimal() Let’s now compare the observed in_bed data with the simulated number of infectious individuals: sir_output &lt;- sir_model(14, 0.0026, 0.565, dt = 0.1) sir_daily &lt;- sir_output %&gt;% group_by(day = floor(t)) %&gt;% summarize(I_simulated = mean(I)) observed_data &lt;- outbreak_data %&gt;% mutate(day = as.numeric(date - min(date))) %&gt;% select(day, in_bed) plot_data &lt;- left_join(observed_data, sir_daily, by = &quot;day&quot;) %&gt;% pivot_longer(cols = c(in_bed, I_simulated), names_to = &quot;type&quot;, values_to = &quot;count&quot;) ggplot(plot_data, aes(x = day, y = count, color = type)) + geom_line(linewidth = 1.2) + geom_point(size = 2, alpha = 0.8) + scale_x_continuous(breaks = 0:max(plot_data$day)) + labs(title = &quot;Observed vs Simulated Infections&quot;, x = &quot;Days Since Outbreak Start&quot;, y = &quot;Number of Students&quot;, color = &quot;Data Type&quot;) + theme_minimal() + theme(axis.text.x = element_text(angle = 0)) These compartmental models can be done using population-based equations, like here. One funadmental issue with those though, is that it is very hard to model heterogeneity in the population. In reality, we have clusters of people that are not vaccinated for example. Using the equations above, and adding a V compartment, the model would make the assumption that the vaccinated and unvaccinated are spread evently. That’s why sometimes these models are implemented using agent based models, where individuals are modelled. The mathematics becomes a bit more complicated, but these models allow us to do much more. Below you will find two examples of such models. For the following one, I modelled people moving around two dedicated centers, two cities if you will. There’s very little, but some, movement between the cities. The infection start in city 1 and later also spreads to city 2. 7.2 Time series - Forecasting Forecasting plays a crucial role in infectious disease epidemiology by enabling short-term projections of case counts. These projections help guide timely public health decisions, especially when diseases exhibit seasonal or trend-driven behavior. In this section, we compare two popular time series approaches: Holt-Winters exponential smoothing, which models level, trend, and seasonality using exponentially weighted averages. ARIMA (AutoRegressive Integrated Moving Average), a flexible class of models that can account for autoregressive lags, differencing (trends), and moving average components, including seasonal extensions (SARIMA). Unlike mechanistic models (e.g., SIR), these statistical methods do not rely on assumptions about transmission mechanisms. Instead, they learn from the patterns and structure of historical data to forecast future values. We apply both models to weekly national tick-borne encephalitis (TBE) cases and generate forecasts for the year following a specified historical cutoff. library(dplyr) library(ggplot2) library(forecast) ## Registered S3 method overwritten by &#39;quantmod&#39;: ## method from ## as.zoo.data.frame zoo library(lubridate) library(patchwork) # --- Load and preprocess data --- tbe_local &lt;- read.csv(&quot;data/tick_borne_encephalitis.csv&quot;) tbe_national &lt;- tbe_local %&gt;% mutate(timestamp = as.Date(timestamp)) %&gt;% group_by(timestamp) %&gt;% summarise(cases = sum(cases), .groups = &quot;drop&quot;) # --- Forecasting setup --- year &lt;- 2018 # Change to define cutoff year tbe_national_context &lt;- tbe_national %&gt;% filter(year(timestamp) &lt;= year) tbe_national_future &lt;- tbe_national %&gt;% filter(year(timestamp) == year + 1) %&gt;% arrange(timestamp) # ---- Create time series object ---- context_ts &lt;- ts(tbe_national_context$cases, frequency = 52) # ---- Holt-Winters model ---- hw_model &lt;- HoltWinters(context_ts) forecast_hw &lt;- forecast(hw_model, h = 52) predicted_df_hw &lt;- data.frame( timestamp = seq.Date(from = as.Date(paste0(year + 1, &quot;-01-01&quot;)), by = &quot;week&quot;, length.out = 52), cases = as.numeric(forecast_hw$mean), type = &quot;predicted_hw&quot; ) # ---- ARIMA model ---- arima_model &lt;- auto.arima(context_ts, seasonal = TRUE) forecast_arima &lt;- forecast(arima_model, h = 52) predicted_df_arima &lt;- data.frame( timestamp = seq.Date(from = as.Date(paste0(year + 1, &quot;-01-01&quot;)), by = &quot;week&quot;, length.out = 52), cases = as.numeric(forecast_arima$mean), type = &quot;predicted_arima&quot; ) # ---- Combine all data for plotting ---- context_labeled &lt;- tbe_national_context %&gt;% mutate(type = &quot;historical&quot;) future_labeled &lt;- tbe_national_future %&gt;% mutate(type = &quot;observed&quot;) combined_data &lt;- bind_rows(context_labeled, future_labeled, predicted_df_hw, predicted_df_arima) # ---- Plot full timeline ---- main_plot &lt;- ggplot(combined_data, aes(x = timestamp, y = cases, color = type)) + geom_line(linewidth = 1.2) + scale_color_manual(values = c( &quot;historical&quot; = &quot;#1f77b4&quot;, &quot;observed&quot; = &quot;#2ca02c&quot;, &quot;predicted_hw&quot; = &quot;#d62728&quot;, &quot;predicted_arima&quot; = &quot;#ff7f0e&quot; )) + theme_classic() + labs( title = paste(&quot;TBE Weekly Cases: Forecasting&quot;, year + 1), x = &quot;Time&quot;, y = &quot;Cases&quot;, color = &quot;Data Type&quot; ) + theme( legend.position = &quot;top&quot;, plot.title = element_text(face = &quot;bold&quot;, size = 16) ) # ---- Plot zoomed forecast year ---- zoom_plot &lt;- combined_data %&gt;% filter(year(timestamp) == year + 1) %&gt;% ggplot(aes(x = timestamp, y = cases, color = type)) + geom_line(linewidth = 1.2) + scale_color_manual(values = c( &quot;historical&quot; = &quot;#1f77b4&quot;, &quot;observed&quot; = &quot;#2ca02c&quot;, &quot;predicted_hw&quot; = &quot;#d62728&quot;, &quot;predicted_arima&quot; = &quot;#ff7f0e&quot; )) + theme_classic() + labs( title = paste(&quot;Zoom: Forecasts vs Observed in&quot;, year + 1), x = &quot;Week&quot;, y = &quot;Cases&quot; ) + theme( legend.position = &quot;none&quot;, plot.title = element_text(face = &quot;bold&quot;) ) # ---- Combine and show ---- main_plot / zoom_plot + plot_layout(heights = c(2, 1)) This analysis demonstrates how different statistical forecasting methods—Holt-Winters vs ARIMA—perform on the same epidemiological time series. While Holt-Winters is intuitive and captures seasonality well, ARIMA can offer greater flexibility in modeling autocorrelated structures. Comparing their predictions side-by-side allows us to evaluate model fit and choose an approach best suited for early warning or planning systems. 7.3 Using and applying models "],["communication-and-sharing-of-code-and-data.html", "Chapter 8 Communication and sharing of code and data 8.1 Writing code: best practices 8.2 Github 8.3 Reports using Markdown 8.4 Open science 8.5 Communities and forums 8.6 How to use Chat-GPT", " Chapter 8 Communication and sharing of code and data 8.1 Writing code: best practices 8.2 Github 8.3 Reports using Markdown 8.4 Open science 8.5 Communities and forums 8.6 How to use Chat-GPT "],["recommended-reading.html", "Chapter 9 Recommended Reading 9.1 Recommended textbooks and courses 9.2 Useful packages", " Chapter 9 Recommended Reading 9.1 Recommended textbooks and courses https://epirhandbook.com/en/new_pages/ggplot_basics.html: great pieces on ggplot (chapter 30) ## Datasources 9.2 Useful packages "],["references.html", "References", " References Chippaux, J. P., &amp; Chippaux, A. (2018). Yellow fever in africa and the americas: A historical and epidemiological perspective. Journal of Venomous Animals and Toxins Including Tropical Diseases, 24. https://doi.org/10.1186/s40409-018-0162-y "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
